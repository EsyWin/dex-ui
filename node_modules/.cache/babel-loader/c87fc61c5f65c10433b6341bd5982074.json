{"ast":null,"code":"var _jsxFileName = \"/home/dev/Code/dex-ui/src/utils/connection.tsx\";\nimport { useLocalStorageState } from './utils';\nimport { Account, Connection } from '@solana/web3.js';\nimport React, { useContext, useEffect, useMemo, useRef } from 'react';\nimport { setCache, useAsyncData } from './fetch-loop';\nimport tuple from 'immutable-tuple';\nexport const endpoints = [// { url: 'https://raydium.rpcpool.com', weight: 100 },\n// { url: 'https://solana-api.tt-prod.net', weight: 100 }\n{\n  url: 'https://solana-api.projectserum.com',\n  weight: 100\n} // { url: 'https://raydium.genesysgo.net', weight: 100 }\n];\nexport function getRandomEndpoint() {\n  let pointer = 0;\n  const random = Math.random() * 100;\n  let api = endpoints[0].url;\n\n  for (const endpoint of endpoints) {\n    if (random > pointer + endpoint.weight) {\n      pointer += pointer + endpoint.weight;\n    } else if (random >= pointer && random < pointer + endpoint.weight) {\n      api = endpoint.url;\n      break;\n    } else {\n      api = endpoint.url;\n      break;\n    }\n  }\n\n  return api;\n}\nexport const ENDPOINTS = [{\n  name: 'mainnet-beta',\n  // endpoint: 'https://solana-api.projectserum.com',\n  endpoint: getRandomEndpoint(),\n  custom: false\n}, {\n  name: 'localnet',\n  endpoint: 'http://127.0.0.1:8899',\n  custom: false\n}];\nconst accountListenerCount = new Map();\nconst ConnectionContext = React.createContext(null);\nexport function ConnectionProvider({\n  children\n}) {\n  const [endpoint, setEndpoint] = useLocalStorageState('connectionEndpts', ENDPOINTS[0].endpoint);\n  const [customEndpoints, setCustomEndpoints] = useLocalStorageState('customConnectionEndpoints', []);\n  const availableEndpoints = ENDPOINTS.concat(customEndpoints);\n  const connection = useMemo(() => new Connection(endpoint, 'recent'), [endpoint]);\n  const sendConnection = useMemo(() => new Connection(endpoint, 'recent'), [endpoint]); // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n\n  useEffect(() => {\n    const id = connection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = sendConnection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      sendConnection.removeAccountChangeListener(id);\n    };\n  }, [sendConnection]);\n  useEffect(() => {\n    const id = sendConnection.onSlotChange(() => null);\n    return () => {\n      sendConnection.removeSlotChangeListener(id);\n    };\n  }, [sendConnection]);\n  return /*#__PURE__*/React.createElement(ConnectionContext.Provider, {\n    value: {\n      endpoint,\n      setEndpoint,\n      connection,\n      sendConnection,\n      availableEndpoints,\n      setCustomEndpoints\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useConnection() {\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return context.connection;\n}\nexport function useSendConnection() {\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return context.sendConnection;\n}\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return {\n    endpoint: context.endpoint,\n    endpointInfo: context.availableEndpoints.find(info => info.endpoint === context.endpoint),\n    setEndpoint: context.setEndpoint,\n    availableEndpoints: context.availableEndpoints,\n    setCustomEndpoints: context.setCustomEndpoints\n  };\n}\nexport function useAccountInfo(publicKey) {\n  const connection = useConnection();\n  const cacheKey = tuple(connection, publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58());\n  const [accountInfo, loaded] = useAsyncData(async () => publicKey ? connection.getAccountInfo(publicKey) : null, cacheKey, {\n    refreshInterval: 60000\n  });\n  useEffect(() => {\n    if (!publicKey) {\n      return;\n    }\n\n    if (accountListenerCount.has(cacheKey)) {\n      let currentItem = accountListenerCount.get(cacheKey);\n      ++currentItem.count;\n    } else {\n      let previousInfo = null;\n      const subscriptionId = connection.onAccountChange(publicKey, info => {\n        if (!previousInfo || !previousInfo.data.equals(info.data) || previousInfo.lamports !== info.lamports) {\n          previousInfo = info;\n          setCache(cacheKey, info);\n        }\n      });\n      accountListenerCount.set(cacheKey, {\n        count: 1,\n        subscriptionId\n      });\n    }\n\n    return () => {\n      let currentItem = accountListenerCount.get(cacheKey);\n      let nextCount = currentItem.count - 1;\n\n      if (nextCount <= 0) {\n        connection.removeAccountChangeListener(currentItem.subscriptionId);\n        accountListenerCount.delete(cacheKey);\n      } else {\n        --currentItem.count;\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey]);\n  const previousInfoRef = useRef(null);\n\n  if (!accountInfo || !previousInfoRef.current || !previousInfoRef.current.data.equals(accountInfo.data) || previousInfoRef.current.lamports !== accountInfo.lamports) {\n    previousInfoRef.current = accountInfo;\n  }\n\n  return [previousInfoRef.current, loaded];\n}\nexport function useAccountData(publicKey) {\n  const [accountInfo] = useAccountInfo(publicKey);\n  return accountInfo && accountInfo.data;\n}","map":{"version":3,"sources":["/home/dev/Code/dex-ui/src/utils/connection.tsx"],"names":["useLocalStorageState","Account","Connection","React","useContext","useEffect","useMemo","useRef","setCache","useAsyncData","tuple","endpoints","url","weight","getRandomEndpoint","pointer","random","Math","api","endpoint","ENDPOINTS","name","custom","accountListenerCount","Map","ConnectionContext","createContext","ConnectionProvider","children","setEndpoint","customEndpoints","setCustomEndpoints","availableEndpoints","concat","connection","sendConnection","id","onAccountChange","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","useConnection","context","Error","useSendConnection","useConnectionConfig","endpointInfo","find","info","useAccountInfo","cacheKey","toBase58","accountInfo","loaded","getAccountInfo","refreshInterval","has","currentItem","get","count","previousInfo","subscriptionId","data","equals","lamports","set","nextCount","delete","previousInfoRef","current","useAccountData"],"mappings":"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","sourcesContent":["import { useLocalStorageState } from './utils';\r\nimport { Account, AccountInfo, Connection, PublicKey } from '@solana/web3.js';\r\nimport React, { useContext, useEffect, useMemo, useRef } from 'react';\r\nimport { setCache, useAsyncData } from './fetch-loop';\r\nimport tuple from 'immutable-tuple';\r\nimport { ConnectionContextValues, EndpointInfo } from './types';\r\n\r\n\r\nexport const endpoints = [\r\n  // { url: 'https://raydium.rpcpool.com', weight: 100 },\r\n  // { url: 'https://solana-api.tt-prod.net', weight: 100 }\r\n  { url: 'https://solana-api.projectserum.com', weight: 100 }\r\n  // { url: 'https://raydium.genesysgo.net', weight: 100 }\r\n]\r\n\r\nexport function getRandomEndpoint() {\r\n  let pointer = 0\r\n  const random = Math.random() * 100\r\n  let api = endpoints[0].url\r\n\r\n  for (const endpoint of endpoints) {\r\n    if (random > pointer + endpoint.weight) {\r\n      pointer += pointer + endpoint.weight\r\n    } else if (random >= pointer && random < pointer + endpoint.weight) {\r\n      api = endpoint.url\r\n      break\r\n    } else {\r\n      api = endpoint.url\r\n      break\r\n    }\r\n  }\r\n\r\n  return api\r\n}\r\n\r\nexport const ENDPOINTS: EndpointInfo[] = [\r\n  {\r\n    name: 'mainnet-beta',\r\n    // endpoint: 'https://solana-api.projectserum.com',\r\n    endpoint: getRandomEndpoint(),\r\n    custom: false,\r\n  },\r\n  { name: 'localnet', endpoint: 'http://127.0.0.1:8899', custom: false },\r\n];\r\n\r\nconst accountListenerCount = new Map();\r\n\r\nconst ConnectionContext: React.Context<null | ConnectionContextValues> = React.createContext<null | ConnectionContextValues>(\r\n  null,\r\n);\r\n\r\nexport function ConnectionProvider({ children }) {\r\n  const [endpoint, setEndpoint] = useLocalStorageState<string>(\r\n    'connectionEndpts',\r\n    ENDPOINTS[0].endpoint,\r\n  );\r\n  const [customEndpoints, setCustomEndpoints] = useLocalStorageState<\r\n    EndpointInfo[]\r\n  >('customConnectionEndpoints', []);\r\n  const availableEndpoints = ENDPOINTS.concat(customEndpoints);\r\n\r\n  const connection = useMemo(() => new Connection(endpoint, 'recent'), [\r\n    endpoint,\r\n  ]);\r\n  const sendConnection = useMemo(() => new Connection(endpoint, 'recent'), [\r\n    endpoint,\r\n  ]);\r\n\r\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\r\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\r\n  // This is a hack to prevent the list from every getting empty\r\n  useEffect(() => {\r\n    const id = connection.onAccountChange(new Account().publicKey, () => {});\r\n    return () => {\r\n      connection.removeAccountChangeListener(id);\r\n    };\r\n  }, [connection]);\r\n\r\n  useEffect(() => {\r\n    const id = connection.onSlotChange(() => null);\r\n    return () => {\r\n      connection.removeSlotChangeListener(id);\r\n    };\r\n  }, [connection]);\r\n\r\n  useEffect(() => {\r\n    const id = sendConnection.onAccountChange(\r\n      new Account().publicKey,\r\n      () => {},\r\n    );\r\n    return () => {\r\n      sendConnection.removeAccountChangeListener(id);\r\n    };\r\n  }, [sendConnection]);\r\n\r\n  useEffect(() => {\r\n    const id = sendConnection.onSlotChange(() => null);\r\n    return () => {\r\n      sendConnection.removeSlotChangeListener(id);\r\n    };\r\n  }, [sendConnection]);\r\n\r\n  return (\r\n    <ConnectionContext.Provider\r\n      value={{\r\n        endpoint,\r\n        setEndpoint,\r\n        connection,\r\n        sendConnection,\r\n        availableEndpoints,\r\n        setCustomEndpoints,\r\n      }}\r\n    >\r\n      {children}\r\n    </ConnectionContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useConnection() {\r\n  const context = useContext(ConnectionContext);\r\n  if (!context) {\r\n    throw new Error('Missing connection context');\r\n  }\r\n  return context.connection;\r\n}\r\n\r\nexport function useSendConnection() {\r\n  const context = useContext(ConnectionContext);\r\n  if (!context) {\r\n    throw new Error('Missing connection context');\r\n  }\r\n  return context.sendConnection;\r\n}\r\n\r\nexport function useConnectionConfig() {\r\n  const context = useContext(ConnectionContext);\r\n  if (!context) {\r\n    throw new Error('Missing connection context');\r\n  }\r\n  return {\r\n    endpoint: context.endpoint,\r\n    endpointInfo: context.availableEndpoints.find(\r\n      (info) => info.endpoint === context.endpoint,\r\n    ),\r\n    setEndpoint: context.setEndpoint,\r\n    availableEndpoints: context.availableEndpoints,\r\n    setCustomEndpoints: context.setCustomEndpoints,\r\n  };\r\n}\r\n\r\nexport function useAccountInfo(\r\n  publicKey: PublicKey | undefined | null,\r\n): [AccountInfo<Buffer> | null | undefined, boolean] {\r\n  const connection = useConnection();\r\n  const cacheKey = tuple(connection, publicKey?.toBase58());\r\n  const [accountInfo, loaded] = useAsyncData<AccountInfo<Buffer> | null>(\r\n    async () => (publicKey ? connection.getAccountInfo(publicKey) : null),\r\n    cacheKey,\r\n    { refreshInterval: 60_000 },\r\n  );\r\n  useEffect(() => {\r\n    if (!publicKey) {\r\n      return;\r\n    }\r\n    if (accountListenerCount.has(cacheKey)) {\r\n      let currentItem = accountListenerCount.get(cacheKey);\r\n      ++currentItem.count;\r\n    } else {\r\n      let previousInfo: AccountInfo<Buffer> | null = null;\r\n      const subscriptionId = connection.onAccountChange(publicKey, (info) => {\r\n        if (\r\n          !previousInfo ||\r\n          !previousInfo.data.equals(info.data) ||\r\n          previousInfo.lamports !== info.lamports\r\n        ) {\r\n          previousInfo = info;\r\n          setCache(cacheKey, info);\r\n        }\r\n      });\r\n      accountListenerCount.set(cacheKey, { count: 1, subscriptionId });\r\n    }\r\n    return () => {\r\n      let currentItem = accountListenerCount.get(cacheKey);\r\n      let nextCount = currentItem.count - 1;\r\n      if (nextCount <= 0) {\r\n        connection.removeAccountChangeListener(currentItem.subscriptionId);\r\n        accountListenerCount.delete(cacheKey);\r\n      } else {\r\n        --currentItem.count;\r\n      }\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [cacheKey]);\r\n  const previousInfoRef = useRef<AccountInfo<Buffer> | null | undefined>(null);\r\n  if (\r\n    !accountInfo ||\r\n    !previousInfoRef.current ||\r\n    !previousInfoRef.current.data.equals(accountInfo.data) ||\r\n    previousInfoRef.current.lamports !== accountInfo.lamports\r\n  ) {\r\n    previousInfoRef.current = accountInfo;\r\n  }\r\n  return [previousInfoRef.current, loaded];\r\n}\r\n\r\nexport function useAccountData(publicKey) {\r\n  const [accountInfo] = useAccountInfo(publicKey);\r\n  return accountInfo && accountInfo.data;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}