{"ast":null,"code":"import { notify } from './notifications';\nimport { getDecimalCount, sleep } from './utils';\nimport { getSelectedTokenAccountForMint } from './markets';\nimport { Account, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';\nimport { Token, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport BN from 'bn.js';\nimport { DexInstructions, Market, OpenOrders, parseInstructionErrorResponse, TokenInstructions } from '@project-serum/serum';\nimport { Buffer } from 'buffer';\nimport assert from 'assert';\nimport { struct } from 'superstruct';\nimport { getTokenByMintAddress } from './tokens';\nexport async function createTokenAccountTransaction({\n  connection,\n  wallet,\n  mintPublicKey\n}) {\n  const ata = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mintPublicKey, wallet.publicKey);\n  const transaction = new Transaction();\n  transaction.add(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mintPublicKey, ata, wallet.publicKey, wallet.publicKey));\n  return {\n    transaction,\n    newAccountPubkey: ata\n  };\n}\nexport async function settleFunds({\n  market,\n  openOrders,\n  connection,\n  wallet,\n  baseCurrencyAccount,\n  quoteCurrencyAccount,\n  sendNotification = true,\n  usdcRef = undefined,\n  usdtRef = undefined\n}) {\n  if (!market || !wallet || !connection || !openOrders || !baseCurrencyAccount && !quoteCurrencyAccount) {\n    if (sendNotification) {\n      notify({\n        message: 'Not connected'\n      });\n    }\n\n    return;\n  }\n\n  let createAccountTransaction;\n  let baseCurrencyAccountPubkey = baseCurrencyAccount === null || baseCurrencyAccount === void 0 ? void 0 : baseCurrencyAccount.pubkey;\n  let quoteCurrencyAccountPubkey = quoteCurrencyAccount === null || quoteCurrencyAccount === void 0 ? void 0 : quoteCurrencyAccount.pubkey;\n\n  if (!baseCurrencyAccountPubkey) {\n    const result = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.baseMintAddress\n    });\n    baseCurrencyAccountPubkey = result === null || result === void 0 ? void 0 : result.newAccountPubkey;\n    createAccountTransaction = result === null || result === void 0 ? void 0 : result.transaction;\n  }\n\n  if (!quoteCurrencyAccountPubkey) {\n    const result = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.quoteMintAddress\n    });\n    quoteCurrencyAccountPubkey = result === null || result === void 0 ? void 0 : result.newAccountPubkey;\n    createAccountTransaction = result === null || result === void 0 ? void 0 : result.transaction;\n  }\n\n  let referrerQuoteWallet = null;\n\n  if (market.supportsReferralFees) {\n    const quoteToken = getTokenByMintAddress(market.quoteMintAddress.toBase58());\n\n    if (quoteToken === null || quoteToken === void 0 ? void 0 : quoteToken.referrer) {\n      referrerQuoteWallet = new PublicKey(quoteToken === null || quoteToken === void 0 ? void 0 : quoteToken.referrer);\n    }\n  }\n\n  const {\n    transaction: settleFundsTransaction,\n    signers: settleFundsSigners\n  } = await market.makeSettleFundsTransaction(connection, openOrders, baseCurrencyAccountPubkey, quoteCurrencyAccountPubkey, referrerQuoteWallet);\n  let transaction = mergeTransactions([createAccountTransaction, settleFundsTransaction]);\n  return await sendTransaction({\n    transaction,\n    signers: settleFundsSigners,\n    wallet,\n    connection,\n    sendingMessage: 'Settling funds...',\n    sendNotification\n  });\n}\nexport async function settleAllFunds({\n  connection,\n  wallet,\n  tokenAccounts,\n  markets,\n  selectedTokenAccounts\n}) {\n  if (!markets || !wallet || !connection || !tokenAccounts) {\n    return;\n  }\n\n  const programIds = [];\n  markets.reduce((cumulative, m) => {\n    // @ts-ignore\n    cumulative.push(m._programId);\n    return cumulative;\n  }, []).forEach(programId => {\n    if (!programIds.find(p => p.equals(programId))) {\n      programIds.push(programId);\n    }\n  });\n\n  const getOpenOrdersAccountsForProgramId = async programId => {\n    const openOrdersAccounts = await OpenOrders.findForOwner(connection, wallet.publicKey, programId);\n    return openOrdersAccounts.filter(openOrders => openOrders.baseTokenFree.toNumber() || openOrders.quoteTokenFree.toNumber());\n  };\n\n  const openOrdersAccountsForProgramIds = await Promise.all(programIds.map(programId => getOpenOrdersAccountsForProgramId(programId)));\n  const openOrdersAccounts = openOrdersAccountsForProgramIds.reduce((accounts, current) => accounts.concat(current), []);\n  const settleTransactions = (await Promise.all(openOrdersAccounts.map(openOrdersAccount => {\n    var _getSelectedTokenAcco, _getSelectedTokenAcco2;\n\n    const market = markets.find(m => {\n      var _m$_decoded, _m$_decoded$ownAddres;\n\n      return (// @ts-ignore\n        (_m$_decoded = m._decoded) === null || _m$_decoded === void 0 ? void 0 : (_m$_decoded$ownAddres = _m$_decoded.ownAddress) === null || _m$_decoded$ownAddres === void 0 ? void 0 : _m$_decoded$ownAddres.equals(openOrdersAccount.market)\n      );\n    });\n\n    if (openOrdersAccount.baseTokenFree.isZero() && openOrdersAccount.quoteTokenFree.isZero()) {\n      // nothing to settle for this market.\n      return null;\n    }\n\n    const baseMint = market === null || market === void 0 ? void 0 : market.baseMintAddress;\n    const quoteMint = market === null || market === void 0 ? void 0 : market.quoteMintAddress;\n    const selectedBaseTokenAccount = (_getSelectedTokenAcco = getSelectedTokenAccountForMint(tokenAccounts, baseMint, baseMint && selectedTokenAccounts && selectedTokenAccounts[baseMint.toBase58()])) === null || _getSelectedTokenAcco === void 0 ? void 0 : _getSelectedTokenAcco.pubkey;\n    const selectedQuoteTokenAccount = (_getSelectedTokenAcco2 = getSelectedTokenAccountForMint(tokenAccounts, quoteMint, quoteMint && selectedTokenAccounts && selectedTokenAccounts[quoteMint.toBase58()])) === null || _getSelectedTokenAcco2 === void 0 ? void 0 : _getSelectedTokenAcco2.pubkey;\n\n    if (!selectedBaseTokenAccount || !selectedQuoteTokenAccount) {\n      return null;\n    }\n\n    return market && market.makeSettleFundsTransaction(connection, openOrdersAccount, selectedBaseTokenAccount, selectedQuoteTokenAccount);\n  }))).filter(x => !!x);\n  if (!settleTransactions || settleTransactions.length === 0) return;\n  const transactions = settleTransactions.slice(0, 4).map(t => t.transaction);\n  const signers = [];\n  settleTransactions.reduce((cumulative, t) => cumulative.concat(t.signers), []).forEach(signer => {\n    if (!signers.find(s => s.publicKey.equals(signer.publicKey))) {\n      signers.push(signer);\n    }\n  });\n  const transaction = mergeTransactions(transactions);\n  return await sendTransaction({\n    transaction,\n    signers,\n    wallet,\n    connection\n  });\n}\nexport async function cancelOrder(params) {\n  return cancelOrders({ ...params,\n    orders: [params.order]\n  });\n}\nexport async function cancelOrders({\n  market,\n  wallet,\n  connection,\n  orders\n}) {\n  const transaction = market.makeMatchOrdersTransaction(5);\n  orders.forEach(order => {\n    transaction.add(market.makeCancelOrderInstruction(connection, wallet.publicKey, order));\n  });\n  transaction.add(market.makeMatchOrdersTransaction(5));\n  return await sendTransaction({\n    transaction,\n    wallet,\n    connection,\n    sendingMessage: 'Sending cancel...'\n  });\n}\nexport async function placeOrder({\n  side,\n  price,\n  size,\n  orderType,\n  market,\n  connection,\n  wallet,\n  baseCurrencyAccount,\n  quoteCurrencyAccount,\n  feeDiscountPubkey = undefined\n}) {\n  var _market$minOrderSize, _market$tickSize;\n\n  let formattedMinOrderSize = (market === null || market === void 0 ? void 0 : (_market$minOrderSize = market.minOrderSize) === null || _market$minOrderSize === void 0 ? void 0 : _market$minOrderSize.toFixed(getDecimalCount(market.minOrderSize))) || (market === null || market === void 0 ? void 0 : market.minOrderSize);\n  let formattedTickSize = (market === null || market === void 0 ? void 0 : (_market$tickSize = market.tickSize) === null || _market$tickSize === void 0 ? void 0 : _market$tickSize.toFixed(getDecimalCount(market.tickSize))) || (market === null || market === void 0 ? void 0 : market.tickSize);\n\n  const isIncrement = (num, step) => Math.abs(num / step % 1) < 1e-5 || Math.abs(num / step % 1 - 1) < 1e-5;\n\n  if (isNaN(price)) {\n    notify({\n      message: 'Invalid price',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (isNaN(size)) {\n    notify({\n      message: 'Invalid size',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!wallet || !wallet.publicKey) {\n    notify({\n      message: 'Connect wallet',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!market) {\n    notify({\n      message: 'Invalid  market',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!isIncrement(size, market.minOrderSize)) {\n    notify({\n      message: `Size must be an increment of ${formattedMinOrderSize}`,\n      type: 'error'\n    });\n    return;\n  }\n\n  if (size < market.minOrderSize) {\n    notify({\n      message: 'Size too small',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!isIncrement(price, market.tickSize)) {\n    notify({\n      message: `Price must be an increment of ${formattedTickSize}`,\n      type: 'error'\n    });\n    return;\n  }\n\n  if (price < market.tickSize) {\n    notify({\n      message: 'Price under tick size',\n      type: 'error'\n    });\n    return;\n  }\n\n  const owner = wallet.publicKey;\n  const transaction = new Transaction();\n  const signers = [];\n\n  if (!baseCurrencyAccount) {\n    const {\n      transaction: createAccountTransaction,\n      newAccountPubkey\n    } = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.baseMintAddress\n    });\n    transaction.add(createAccountTransaction);\n    baseCurrencyAccount = newAccountPubkey;\n  }\n\n  if (!quoteCurrencyAccount) {\n    const {\n      transaction: createAccountTransaction,\n      newAccountPubkey\n    } = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.quoteMintAddress\n    });\n    transaction.add(createAccountTransaction);\n    quoteCurrencyAccount = newAccountPubkey;\n  }\n\n  const payer = side === 'sell' ? baseCurrencyAccount : quoteCurrencyAccount;\n\n  if (!payer) {\n    notify({\n      message: 'Need an SPL token account for cost currency',\n      type: 'error'\n    });\n    return;\n  }\n\n  const params = {\n    owner,\n    payer,\n    side,\n    price,\n    size,\n    orderType,\n    feeDiscountPubkey: feeDiscountPubkey || null\n  };\n  console.log(params);\n  const matchOrderstransaction = market.makeMatchOrdersTransaction(5);\n  transaction.add(matchOrderstransaction);\n  const startTime = getUnixTs();\n  let {\n    transaction: placeOrderTx,\n    signers: placeOrderSigners\n  } = await market.makePlaceOrderTransaction(connection, params, 120000, 120000);\n  const endTime = getUnixTs();\n  console.log(`Creating order transaction took ${endTime - startTime}`);\n  transaction.add(placeOrderTx);\n  transaction.add(market.makeMatchOrdersTransaction(5));\n  signers.push(...placeOrderSigners);\n  return await sendTransaction({\n    transaction,\n    wallet,\n    connection,\n    signers,\n    sendingMessage: 'Sending order...'\n  });\n}\nexport async function listMarket({\n  connection,\n  wallet,\n  baseMint,\n  quoteMint,\n  baseLotSize,\n  quoteLotSize,\n  dexProgramId\n}) {\n  const market = new Account();\n  const requestQueue = new Account();\n  const eventQueue = new Account();\n  const bids = new Account();\n  const asks = new Account();\n  const baseVault = new Account();\n  const quoteVault = new Account();\n  const feeRateBps = 0;\n  const quoteDustThreshold = new BN(100);\n\n  async function getVaultOwnerAndNonce() {\n    const nonce = new BN(0);\n\n    while (true) {\n      try {\n        const vaultOwner = await PublicKey.createProgramAddress([market.publicKey.toBuffer(), nonce.toArrayLike(Buffer, 'le', 8)], dexProgramId);\n        return [vaultOwner, nonce];\n      } catch (e) {\n        nonce.iaddn(1);\n      }\n    }\n  }\n\n  const [vaultOwner, vaultSignerNonce] = await getVaultOwnerAndNonce();\n  const tx1 = new Transaction();\n  tx1.add(SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: baseVault.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(165),\n    space: 165,\n    programId: TokenInstructions.TOKEN_PROGRAM_ID\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: quoteVault.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(165),\n    space: 165,\n    programId: TokenInstructions.TOKEN_PROGRAM_ID\n  }), TokenInstructions.initializeAccount({\n    account: baseVault.publicKey,\n    mint: baseMint,\n    owner: vaultOwner\n  }), TokenInstructions.initializeAccount({\n    account: quoteVault.publicKey,\n    mint: quoteMint,\n    owner: vaultOwner\n  }));\n  const tx2 = new Transaction();\n  tx2.add(SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: market.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(Market.getLayout(dexProgramId).span),\n    space: Market.getLayout(dexProgramId).span,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: requestQueue.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(5120 + 12),\n    space: 5120 + 12,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: eventQueue.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(262144 + 12),\n    space: 262144 + 12,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: bids.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\n    space: 65536 + 12,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: asks.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\n    space: 65536 + 12,\n    programId: dexProgramId\n  }), DexInstructions.initializeMarket({\n    market: market.publicKey,\n    requestQueue: requestQueue.publicKey,\n    eventQueue: eventQueue.publicKey,\n    bids: bids.publicKey,\n    asks: asks.publicKey,\n    baseVault: baseVault.publicKey,\n    quoteVault: quoteVault.publicKey,\n    baseMint,\n    quoteMint,\n    baseLotSize: new BN(baseLotSize),\n    quoteLotSize: new BN(quoteLotSize),\n    feeRateBps,\n    vaultSignerNonce,\n    quoteDustThreshold,\n    programId: dexProgramId,\n    authority: undefined\n  }));\n  const signedTransactions = await signTransactions({\n    transactionsAndSigners: [{\n      transaction: tx1,\n      signers: [baseVault, quoteVault]\n    }, {\n      transaction: tx2,\n      signers: [market, requestQueue, eventQueue, bids, asks]\n    }],\n    wallet,\n    connection\n  });\n\n  for (let signedTransaction of signedTransactions) {\n    await sendSignedTransaction({\n      signedTransaction,\n      connection\n    });\n  }\n\n  return market.publicKey;\n}\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nconst DEFAULT_TIMEOUT = 15000;\nexport async function sendTransaction({\n  transaction,\n  wallet,\n  signers = [],\n  connection,\n  sendingMessage = 'Sending transaction...',\n  sentMessage = 'Transaction sent',\n  successMessage = 'Transaction confirmed',\n  timeout = DEFAULT_TIMEOUT,\n  sendNotification = true\n}) {\n  const signedTransaction = await signTransaction({\n    transaction,\n    wallet,\n    signers,\n    connection\n  });\n  return await sendSignedTransaction({\n    signedTransaction,\n    connection,\n    sendingMessage,\n    sentMessage,\n    successMessage,\n    timeout,\n    sendNotification\n  });\n}\nexport async function signTransaction({\n  transaction,\n  wallet,\n  signers = [],\n  connection\n}) {\n  transaction.recentBlockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  return await wallet.signTransaction(transaction);\n}\nexport async function signTransactions({\n  transactionsAndSigners,\n  wallet,\n  connection\n}) {\n  const blockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transactionsAndSigners.forEach(({\n    transaction,\n    signers = []\n  }) => {\n    transaction.recentBlockhash = blockhash;\n    transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n\n    if ((signers === null || signers === void 0 ? void 0 : signers.length) > 0) {\n      transaction.partialSign(...signers);\n    }\n  });\n  return await wallet.signAllTransactions(transactionsAndSigners.map(({\n    transaction\n  }) => transaction));\n}\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  sendingMessage = 'Sending transaction...',\n  sentMessage = 'Transaction sent',\n  successMessage = 'Transaction confirmed',\n  timeout = DEFAULT_TIMEOUT,\n  sendNotification = true\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n\n  if (sendNotification) {\n    notify({\n      message: sendingMessage\n    });\n  }\n\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n\n  if (sendNotification) {\n    notify({\n      message: sentMessage,\n      type: 'success',\n      txid\n    });\n  }\n\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleep(300);\n    }\n  })();\n\n  try {\n    await awaitTransactionSignatureConfirmation(txid, timeout, connection);\n  } catch (err) {\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\n    } catch (e) {}\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith('Program log: ')) {\n            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\n          }\n        }\n      }\n\n      let parsedError;\n\n      if (typeof simulateResult.err == 'object' && 'InstructionError' in simulateResult.err) {\n        const parsedErrorInfo = parseInstructionErrorResponse(signedTransaction, simulateResult.err['InstructionError']);\n        parsedError = parsedErrorInfo.error;\n      } else {\n        parsedError = JSON.stringify(simulateResult.err);\n      }\n\n      throw new Error(parsedError);\n    }\n\n    throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  if (sendNotification) {\n    notify({\n      message: successMessage,\n      type: 'success',\n      txid\n    });\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return txid;\n}\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let done = false;\n  const result = await new Promise((resolve, reject) => {\n    (async () => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n\n        done = true;\n        console.log('Timed out for txid', txid);\n        reject({\n          timeout: true\n        });\n      }, timeout);\n\n      try {\n        connection.onSignature(txid, result => {\n          console.log('WS confirmed', txid, result);\n          done = true;\n\n          if (result.err) {\n            reject(result.err);\n          } else {\n            resolve(result);\n          }\n        }, 'recent');\n        console.log('Set up WS connection', txid);\n      } catch (e) {\n        done = true;\n        console.log('WS error in setup', txid, e);\n      }\n\n      while (!done) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([txid]);\n            const result = signatureStatuses && signatureStatuses.value[0];\n\n            if (!done) {\n              if (!result) {\n                console.log('REST null result for', txid, result);\n              } else if (result.err) {\n                console.log('REST error for', txid, result);\n                done = true;\n                reject(result.err);\n              } else if (!result.confirmations) {\n                console.log('REST no confirmations for', txid, result);\n              } else {\n                console.log('REST confirmation for', txid, result);\n                done = true;\n                resolve(result);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n\n        await sleep(300);\n      }\n    })();\n  });\n  done = true;\n  return result;\n}\n\nfunction mergeTransactions(transactions) {\n  const transaction = new Transaction();\n  transactions.filter(t => t !== undefined).forEach(t => {\n    transaction.add(t);\n  });\n  return transaction;\n}\n\nfunction jsonRpcResult(resultDescription) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([struct({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'any'\n  }), struct({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'null?',\n    result: resultDescription\n  })]);\n}\n\nfunction jsonRpcResultAndContext(resultDescription) {\n  return jsonRpcResult({\n    context: struct({\n      slot: 'number'\n    }),\n    value: resultDescription\n  });\n}\n\nconst AccountInfoResult = struct({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'any',\n  rentEpoch: 'number?'\n});\nexport const GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(struct.array([struct.union(['null', AccountInfoResult])]));\nexport async function getMultipleSolanaAccounts(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: 'recent'\n  }]; // @ts-ignore\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  const res = GetMultipleAccountsAndContextRpcResult(unsafeRes);\n\n  if (res.error) {\n    throw new Error('failed to get info about accounts ' + publicKeys.map(k => k.toBase58()).join(', ') + ': ' + res.error.message);\n  }\n\n  assert(typeof res.result !== 'undefined');\n  const accounts = [];\n\n  for (const account of res.result.value) {\n    let value = null;\n\n    if (res.result.value) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      assert(data[1] === 'base64');\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], 'base64')\n      };\n    }\n\n    accounts.push(value);\n  }\n\n  return {\n    context: {\n      slot: res.result.context.slot\n    },\n    value: Object.fromEntries(accounts.map((account, i) => [publicKeys[i].toBase58(), account]))\n  };\n}\n/** Copy of Connection.simulateTransaction that takes a commitment parameter. */\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = {\n    encoding: 'base64',\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest('simulateTransaction', args);\n\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n\n  return res.result;\n}","map":{"version":3,"sources":["/home/dev/Code/dex-ui/src/utils/send.tsx"],"names":["notify","getDecimalCount","sleep","getSelectedTokenAccountForMint","Account","PublicKey","SystemProgram","Transaction","Token","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","BN","DexInstructions","Market","OpenOrders","parseInstructionErrorResponse","TokenInstructions","Buffer","assert","struct","getTokenByMintAddress","createTokenAccountTransaction","connection","wallet","mintPublicKey","ata","getAssociatedTokenAddress","publicKey","transaction","add","createAssociatedTokenAccountInstruction","newAccountPubkey","settleFunds","market","openOrders","baseCurrencyAccount","quoteCurrencyAccount","sendNotification","usdcRef","undefined","usdtRef","message","createAccountTransaction","baseCurrencyAccountPubkey","pubkey","quoteCurrencyAccountPubkey","result","baseMintAddress","quoteMintAddress","referrerQuoteWallet","supportsReferralFees","quoteToken","toBase58","referrer","settleFundsTransaction","signers","settleFundsSigners","makeSettleFundsTransaction","mergeTransactions","sendTransaction","sendingMessage","settleAllFunds","tokenAccounts","markets","selectedTokenAccounts","programIds","reduce","cumulative","m","push","_programId","forEach","programId","find","p","equals","getOpenOrdersAccountsForProgramId","openOrdersAccounts","findForOwner","filter","baseTokenFree","toNumber","quoteTokenFree","openOrdersAccountsForProgramIds","Promise","all","map","accounts","current","concat","settleTransactions","openOrdersAccount","_decoded","ownAddress","isZero","baseMint","quoteMint","selectedBaseTokenAccount","selectedQuoteTokenAccount","x","length","transactions","slice","t","signer","s","cancelOrder","params","cancelOrders","orders","order","makeMatchOrdersTransaction","makeCancelOrderInstruction","placeOrder","side","price","size","orderType","feeDiscountPubkey","formattedMinOrderSize","minOrderSize","toFixed","formattedTickSize","tickSize","isIncrement","num","step","Math","abs","isNaN","type","owner","payer","console","log","matchOrderstransaction","startTime","getUnixTs","placeOrderTx","placeOrderSigners","makePlaceOrderTransaction","endTime","listMarket","baseLotSize","quoteLotSize","dexProgramId","requestQueue","eventQueue","bids","asks","baseVault","quoteVault","feeRateBps","quoteDustThreshold","getVaultOwnerAndNonce","nonce","vaultOwner","createProgramAddress","toBuffer","toArrayLike","e","iaddn","vaultSignerNonce","tx1","createAccount","fromPubkey","lamports","getMinimumBalanceForRentExemption","space","initializeAccount","account","mint","tx2","getLayout","span","initializeMarket","authority","signedTransactions","signTransactions","transactionsAndSigners","signedTransaction","sendSignedTransaction","Date","getTime","DEFAULT_TIMEOUT","sentMessage","successMessage","timeout","signTransaction","recentBlockhash","getRecentBlockhash","blockhash","setSigners","partialSign","signAllTransactions","rawTransaction","serialize","txid","sendRawTransaction","skipPreflight","done","awaitTransactionSignatureConfirmation","err","Error","simulateResult","simulateTransaction","value","logs","i","line","startsWith","parsedError","parsedErrorInfo","error","JSON","stringify","resolve","reject","setTimeout","onSignature","signatureStatuses","getSignatureStatuses","confirmations","jsonRpcResult","resultDescription","jsonRpcVersion","literal","union","jsonrpc","id","jsonRpcResultAndContext","context","slot","AccountInfoResult","executable","data","rentEpoch","GetMultipleAccountsAndContextRpcResult","array","getMultipleSolanaAccounts","publicKeys","args","k","commitment","unsafeRes","_rpcRequest","res","join","from","Object","fromEntries","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding"],"mappings":"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","sourcesContent":["import { notify } from './notifications';\r\nimport { getDecimalCount, sleep } from './utils';\r\nimport { getSelectedTokenAccountForMint } from './markets';\r\nimport {\r\n  Account,\r\n  AccountInfo,\r\n  Commitment,\r\n  Connection,\r\n  PublicKey,\r\n  RpcResponseAndContext,\r\n  SimulatedTransactionResponse,\r\n  SystemProgram,\r\n  Transaction,\r\n  TransactionSignature,\r\n} from '@solana/web3.js';\r\nimport {\r\n  Token,\r\n  ASSOCIATED_TOKEN_PROGRAM_ID,\r\n  TOKEN_PROGRAM_ID,\r\n} from '@solana/spl-token';\r\nimport BN from 'bn.js';\r\nimport {\r\n  DexInstructions,\r\n  Market,\r\n  OpenOrders,\r\n  parseInstructionErrorResponse,\r\n  TokenInstructions,\r\n} from '@project-serum/serum';\r\nimport { SelectedTokenAccounts, TokenAccount } from './types';\r\nimport { Order } from '@project-serum/serum/lib/market';\r\nimport { Buffer } from 'buffer';\r\nimport assert from 'assert';\r\nimport { struct } from 'superstruct';\r\nimport { WalletAdapter } from '../wallet-adapters';\r\nimport { getTokenByMintAddress } from './tokens';\r\n\r\nexport async function createTokenAccountTransaction({\r\n  connection,\r\n  wallet,\r\n  mintPublicKey,\r\n}: {\r\n  connection: Connection;\r\n  wallet: WalletAdapter;\r\n  mintPublicKey: PublicKey;\r\n}): Promise<{\r\n  transaction: Transaction;\r\n  newAccountPubkey: PublicKey;\r\n}> {\r\n  const ata = await Token.getAssociatedTokenAddress(\r\n    ASSOCIATED_TOKEN_PROGRAM_ID,\r\n    TOKEN_PROGRAM_ID,\r\n    mintPublicKey,\r\n    wallet.publicKey,\r\n  );\r\n  const transaction = new Transaction();\r\n  transaction.add(\r\n    Token.createAssociatedTokenAccountInstruction(\r\n      ASSOCIATED_TOKEN_PROGRAM_ID,\r\n      TOKEN_PROGRAM_ID,\r\n      mintPublicKey,\r\n      ata,\r\n      wallet.publicKey,\r\n      wallet.publicKey,\r\n    ),\r\n  );\r\n  return {\r\n    transaction,\r\n    newAccountPubkey: ata,\r\n  };\r\n}\r\n\r\nexport async function settleFunds({\r\n  market,\r\n  openOrders,\r\n  connection,\r\n  wallet,\r\n  baseCurrencyAccount,\r\n  quoteCurrencyAccount,\r\n  sendNotification = true,\r\n  usdcRef = undefined,\r\n  usdtRef = undefined,\r\n}: {\r\n  market: Market;\r\n  openOrders: OpenOrders;\r\n  connection: Connection;\r\n  wallet: WalletAdapter;\r\n  baseCurrencyAccount: TokenAccount;\r\n  quoteCurrencyAccount: TokenAccount;\r\n  sendNotification?: boolean;\r\n  usdcRef?: PublicKey;\r\n  usdtRef?: PublicKey;\r\n}): Promise<string | undefined> {\r\n  if (\r\n    !market ||\r\n    !wallet ||\r\n    !connection ||\r\n    !openOrders ||\r\n    (!baseCurrencyAccount && !quoteCurrencyAccount)\r\n  ) {\r\n    if (sendNotification) {\r\n      notify({ message: 'Not connected' });\r\n    }\r\n    return;\r\n  }\r\n\r\n  let createAccountTransaction: Transaction | undefined;\r\n  let baseCurrencyAccountPubkey = baseCurrencyAccount?.pubkey;\r\n  let quoteCurrencyAccountPubkey = quoteCurrencyAccount?.pubkey;\r\n\r\n  if (!baseCurrencyAccountPubkey) {\r\n    const result = await createTokenAccountTransaction({\r\n      connection,\r\n      wallet,\r\n      mintPublicKey: market.baseMintAddress,\r\n    });\r\n    baseCurrencyAccountPubkey = result?.newAccountPubkey;\r\n    createAccountTransaction = result?.transaction;\r\n  }\r\n  if (!quoteCurrencyAccountPubkey) {\r\n    const result = await createTokenAccountTransaction({\r\n      connection,\r\n      wallet,\r\n      mintPublicKey: market.quoteMintAddress,\r\n    });\r\n    quoteCurrencyAccountPubkey = result?.newAccountPubkey;\r\n    createAccountTransaction = result?.transaction;\r\n  }\r\n  let referrerQuoteWallet: PublicKey | null = null;\r\n  if (market.supportsReferralFees) {\r\n    const quoteToken = getTokenByMintAddress(\r\n      market.quoteMintAddress.toBase58(),\r\n    );\r\n    if (quoteToken?.referrer) {\r\n      referrerQuoteWallet = new PublicKey(quoteToken?.referrer);\r\n    }\r\n  }\r\n  const {\r\n    transaction: settleFundsTransaction,\r\n    signers: settleFundsSigners,\r\n  } = await market.makeSettleFundsTransaction(\r\n    connection,\r\n    openOrders,\r\n    baseCurrencyAccountPubkey,\r\n    quoteCurrencyAccountPubkey,\r\n    referrerQuoteWallet,\r\n  );\r\n\r\n  let transaction = mergeTransactions([\r\n    createAccountTransaction,\r\n    settleFundsTransaction,\r\n  ]);\r\n\r\n  return await sendTransaction({\r\n    transaction,\r\n    signers: settleFundsSigners,\r\n    wallet,\r\n    connection,\r\n    sendingMessage: 'Settling funds...',\r\n    sendNotification,\r\n  });\r\n}\r\n\r\nexport async function settleAllFunds({\r\n  connection,\r\n  wallet,\r\n  tokenAccounts,\r\n  markets,\r\n  selectedTokenAccounts,\r\n}: {\r\n  connection: Connection;\r\n  wallet: WalletAdapter;\r\n  tokenAccounts: TokenAccount[];\r\n  markets: Market[];\r\n  selectedTokenAccounts?: SelectedTokenAccounts;\r\n}) {\r\n  if (!markets || !wallet || !connection || !tokenAccounts) {\r\n    return;\r\n  }\r\n\r\n  const programIds: PublicKey[] = [];\r\n  markets\r\n    .reduce((cumulative, m) => {\r\n      // @ts-ignore\r\n      cumulative.push(m._programId);\r\n      return cumulative;\r\n    }, [])\r\n    .forEach((programId) => {\r\n      if (!programIds.find((p) => p.equals(programId))) {\r\n        programIds.push(programId);\r\n      }\r\n    });\r\n\r\n  const getOpenOrdersAccountsForProgramId = async (programId) => {\r\n    const openOrdersAccounts = await OpenOrders.findForOwner(\r\n      connection,\r\n      wallet.publicKey,\r\n      programId,\r\n    );\r\n    return openOrdersAccounts.filter(\r\n      (openOrders) =>\r\n        openOrders.baseTokenFree.toNumber() ||\r\n        openOrders.quoteTokenFree.toNumber(),\r\n    );\r\n  };\r\n\r\n  const openOrdersAccountsForProgramIds = await Promise.all(\r\n    programIds.map((programId) => getOpenOrdersAccountsForProgramId(programId)),\r\n  );\r\n  const openOrdersAccounts = openOrdersAccountsForProgramIds.reduce(\r\n    (accounts, current) => accounts.concat(current),\r\n    [],\r\n  );\r\n\r\n  const settleTransactions = (\r\n    await Promise.all(\r\n      openOrdersAccounts.map((openOrdersAccount) => {\r\n        const market = markets.find((m) =>\r\n          // @ts-ignore\r\n          m._decoded?.ownAddress?.equals(openOrdersAccount.market),\r\n        );\r\n        if (\r\n          openOrdersAccount.baseTokenFree.isZero() &&\r\n          openOrdersAccount.quoteTokenFree.isZero()\r\n        ) {\r\n          // nothing to settle for this market.\r\n          return null;\r\n        }\r\n        const baseMint = market?.baseMintAddress;\r\n        const quoteMint = market?.quoteMintAddress;\r\n\r\n        const selectedBaseTokenAccount = getSelectedTokenAccountForMint(\r\n          tokenAccounts,\r\n          baseMint,\r\n          baseMint &&\r\n          selectedTokenAccounts &&\r\n          selectedTokenAccounts[baseMint.toBase58()],\r\n        )?.pubkey;\r\n        const selectedQuoteTokenAccount = getSelectedTokenAccountForMint(\r\n          tokenAccounts,\r\n          quoteMint,\r\n          quoteMint &&\r\n          selectedTokenAccounts &&\r\n          selectedTokenAccounts[quoteMint.toBase58()],\r\n        )?.pubkey;\r\n        if (!selectedBaseTokenAccount || !selectedQuoteTokenAccount) {\r\n          return null;\r\n        }\r\n        return (\r\n          market &&\r\n          market.makeSettleFundsTransaction(\r\n            connection,\r\n            openOrdersAccount,\r\n            selectedBaseTokenAccount,\r\n            selectedQuoteTokenAccount,\r\n          )\r\n        );\r\n      }),\r\n    )\r\n  ).filter(\r\n    (\r\n      x,\r\n    ): x is {\r\n      signers: Account[];\r\n      transaction: Transaction;\r\n      payer: PublicKey;\r\n    } => !!x,\r\n  );\r\n  if (!settleTransactions || settleTransactions.length === 0) return;\r\n\r\n  const transactions = settleTransactions.slice(0, 4).map((t) => t.transaction);\r\n  const signers: Array<Account> = [];\r\n  settleTransactions\r\n    .reduce((cumulative: Array<Account>, t) => cumulative.concat(t.signers), [])\r\n    .forEach((signer) => {\r\n      if (!signers.find((s) => s.publicKey.equals(signer.publicKey))) {\r\n        signers.push(signer);\r\n      }\r\n    });\r\n\r\n  const transaction = mergeTransactions(transactions);\r\n\r\n  return await sendTransaction({\r\n    transaction,\r\n    signers,\r\n    wallet,\r\n    connection,\r\n  });\r\n}\r\n\r\nexport async function cancelOrder(params: {\r\n  market: Market;\r\n  connection: Connection;\r\n  wallet: WalletAdapter;\r\n  order: Order;\r\n}) {\r\n  return cancelOrders({ ...params, orders: [params.order] });\r\n}\r\n\r\nexport async function cancelOrders({\r\n  market,\r\n  wallet,\r\n  connection,\r\n  orders,\r\n}: {\r\n  market: Market;\r\n  wallet: WalletAdapter;\r\n  connection: Connection;\r\n  orders: Order[];\r\n}) {\r\n  const transaction = market.makeMatchOrdersTransaction(5);\r\n  orders.forEach((order) => {\r\n    transaction.add(\r\n      market.makeCancelOrderInstruction(connection, wallet.publicKey, order),\r\n    );\r\n  });\r\n  transaction.add(market.makeMatchOrdersTransaction(5));\r\n  return await sendTransaction({\r\n    transaction,\r\n    wallet,\r\n    connection,\r\n    sendingMessage: 'Sending cancel...',\r\n  });\r\n}\r\n\r\nexport async function placeOrder({\r\n  side,\r\n  price,\r\n  size,\r\n  orderType,\r\n  market,\r\n  connection,\r\n  wallet,\r\n  baseCurrencyAccount,\r\n  quoteCurrencyAccount,\r\n  feeDiscountPubkey = undefined,\r\n}: {\r\n  side: 'buy' | 'sell';\r\n  price: number;\r\n  size: number;\r\n  orderType: 'ioc' | 'postOnly' | 'limit';\r\n  market: Market | undefined | null;\r\n  connection: Connection;\r\n  wallet: WalletAdapter;\r\n  baseCurrencyAccount: PublicKey | undefined;\r\n  quoteCurrencyAccount: PublicKey | undefined;\r\n  feeDiscountPubkey: PublicKey | undefined;\r\n}) {\r\n  let formattedMinOrderSize =\r\n    market?.minOrderSize?.toFixed(getDecimalCount(market.minOrderSize)) ||\r\n    market?.minOrderSize;\r\n  let formattedTickSize =\r\n    market?.tickSize?.toFixed(getDecimalCount(market.tickSize)) ||\r\n    market?.tickSize;\r\n  const isIncrement = (num, step) =>\r\n    Math.abs((num / step) % 1) < 1e-5 ||\r\n    Math.abs(((num / step) % 1) - 1) < 1e-5;\r\n  if (isNaN(price)) {\r\n    notify({ message: 'Invalid price', type: 'error' });\r\n    return;\r\n  }\r\n  if (isNaN(size)) {\r\n    notify({ message: 'Invalid size', type: 'error' });\r\n    return;\r\n  }\r\n  if (!wallet || !wallet.publicKey) {\r\n    notify({ message: 'Connect wallet', type: 'error' });\r\n    return;\r\n  }\r\n  if (!market) {\r\n    notify({ message: 'Invalid  market', type: 'error' });\r\n    return;\r\n  }\r\n  if (!isIncrement(size, market.minOrderSize)) {\r\n    notify({\r\n      message: `Size must be an increment of ${formattedMinOrderSize}`,\r\n      type: 'error',\r\n    });\r\n    return;\r\n  }\r\n  if (size < market.minOrderSize) {\r\n    notify({ message: 'Size too small', type: 'error' });\r\n    return;\r\n  }\r\n  if (!isIncrement(price, market.tickSize)) {\r\n    notify({\r\n      message: `Price must be an increment of ${formattedTickSize}`,\r\n      type: 'error',\r\n    });\r\n    return;\r\n  }\r\n  if (price < market.tickSize) {\r\n    notify({ message: 'Price under tick size', type: 'error' });\r\n    return;\r\n  }\r\n  const owner = wallet.publicKey;\r\n  const transaction = new Transaction();\r\n  const signers: Account[] = [];\r\n\r\n  if (!baseCurrencyAccount) {\r\n    const {\r\n      transaction: createAccountTransaction,\r\n      newAccountPubkey,\r\n    } = await createTokenAccountTransaction({\r\n      connection,\r\n      wallet,\r\n      mintPublicKey: market.baseMintAddress,\r\n    });\r\n    transaction.add(createAccountTransaction);\r\n    baseCurrencyAccount = newAccountPubkey;\r\n  }\r\n  if (!quoteCurrencyAccount) {\r\n    const {\r\n      transaction: createAccountTransaction,\r\n      newAccountPubkey,\r\n    } = await createTokenAccountTransaction({\r\n      connection,\r\n      wallet,\r\n      mintPublicKey: market.quoteMintAddress,\r\n    });\r\n    transaction.add(createAccountTransaction);\r\n    quoteCurrencyAccount = newAccountPubkey;\r\n  }\r\n\r\n  const payer = side === 'sell' ? baseCurrencyAccount : quoteCurrencyAccount;\r\n  if (!payer) {\r\n    notify({\r\n      message: 'Need an SPL token account for cost currency',\r\n      type: 'error',\r\n    });\r\n    return;\r\n  }\r\n  const params = {\r\n    owner,\r\n    payer,\r\n    side,\r\n    price,\r\n    size,\r\n    orderType,\r\n    feeDiscountPubkey: feeDiscountPubkey || null,\r\n  };\r\n  console.log(params);\r\n\r\n  const matchOrderstransaction = market.makeMatchOrdersTransaction(5);\r\n  transaction.add(matchOrderstransaction);\r\n  const startTime = getUnixTs();\r\n  let {\r\n    transaction: placeOrderTx,\r\n    signers: placeOrderSigners,\r\n  } = await market.makePlaceOrderTransaction(\r\n    connection,\r\n    params,\r\n    120_000,\r\n    120_000,\r\n  );\r\n  const endTime = getUnixTs();\r\n  console.log(`Creating order transaction took ${endTime - startTime}`);\r\n  transaction.add(placeOrderTx);\r\n  transaction.add(market.makeMatchOrdersTransaction(5));\r\n  signers.push(...placeOrderSigners);\r\n\r\n  return await sendTransaction({\r\n    transaction,\r\n    wallet,\r\n    connection,\r\n    signers,\r\n    sendingMessage: 'Sending order...',\r\n  });\r\n}\r\n\r\nexport async function listMarket({\r\n  connection,\r\n  wallet,\r\n  baseMint,\r\n  quoteMint,\r\n  baseLotSize,\r\n  quoteLotSize,\r\n  dexProgramId,\r\n}: {\r\n  connection: Connection;\r\n  wallet: WalletAdapter;\r\n  baseMint: PublicKey;\r\n  quoteMint: PublicKey;\r\n  baseLotSize: number;\r\n  quoteLotSize: number;\r\n  dexProgramId: PublicKey;\r\n}) {\r\n  const market = new Account();\r\n  const requestQueue = new Account();\r\n  const eventQueue = new Account();\r\n  const bids = new Account();\r\n  const asks = new Account();\r\n  const baseVault = new Account();\r\n  const quoteVault = new Account();\r\n  const feeRateBps = 0;\r\n  const quoteDustThreshold = new BN(100);\r\n\r\n  async function getVaultOwnerAndNonce() {\r\n    const nonce = new BN(0);\r\n    while (true) {\r\n      try {\r\n        const vaultOwner = await PublicKey.createProgramAddress(\r\n          [market.publicKey.toBuffer(), nonce.toArrayLike(Buffer, 'le', 8)],\r\n          dexProgramId,\r\n        );\r\n        return [vaultOwner, nonce];\r\n      } catch (e) {\r\n        nonce.iaddn(1);\r\n      }\r\n    }\r\n  }\r\n  const [vaultOwner, vaultSignerNonce] = await getVaultOwnerAndNonce();\r\n\r\n  const tx1 = new Transaction();\r\n  tx1.add(\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: baseVault.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(165),\r\n      space: 165,\r\n      programId: TokenInstructions.TOKEN_PROGRAM_ID,\r\n    }),\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: quoteVault.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(165),\r\n      space: 165,\r\n      programId: TokenInstructions.TOKEN_PROGRAM_ID,\r\n    }),\r\n    TokenInstructions.initializeAccount({\r\n      account: baseVault.publicKey,\r\n      mint: baseMint,\r\n      owner: vaultOwner,\r\n    }),\r\n    TokenInstructions.initializeAccount({\r\n      account: quoteVault.publicKey,\r\n      mint: quoteMint,\r\n      owner: vaultOwner,\r\n    }),\r\n  );\r\n\r\n  const tx2 = new Transaction();\r\n  tx2.add(\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: market.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(\r\n        Market.getLayout(dexProgramId).span,\r\n      ),\r\n      space: Market.getLayout(dexProgramId).span,\r\n      programId: dexProgramId,\r\n    }),\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: requestQueue.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(5120 + 12),\r\n      space: 5120 + 12,\r\n      programId: dexProgramId,\r\n    }),\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: eventQueue.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(262144 + 12),\r\n      space: 262144 + 12,\r\n      programId: dexProgramId,\r\n    }),\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: bids.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\r\n      space: 65536 + 12,\r\n      programId: dexProgramId,\r\n    }),\r\n    SystemProgram.createAccount({\r\n      fromPubkey: wallet.publicKey,\r\n      newAccountPubkey: asks.publicKey,\r\n      lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\r\n      space: 65536 + 12,\r\n      programId: dexProgramId,\r\n    }),\r\n    DexInstructions.initializeMarket({\r\n      market: market.publicKey,\r\n      requestQueue: requestQueue.publicKey,\r\n      eventQueue: eventQueue.publicKey,\r\n      bids: bids.publicKey,\r\n      asks: asks.publicKey,\r\n      baseVault: baseVault.publicKey,\r\n      quoteVault: quoteVault.publicKey,\r\n      baseMint,\r\n      quoteMint,\r\n      baseLotSize: new BN(baseLotSize),\r\n      quoteLotSize: new BN(quoteLotSize),\r\n      feeRateBps,\r\n      vaultSignerNonce,\r\n      quoteDustThreshold,\r\n      programId: dexProgramId,\r\n      authority: undefined,\r\n    }),\r\n  );\r\n\r\n  const signedTransactions = await signTransactions({\r\n    transactionsAndSigners: [\r\n      { transaction: tx1, signers: [baseVault, quoteVault] },\r\n      {\r\n        transaction: tx2,\r\n        signers: [market, requestQueue, eventQueue, bids, asks],\r\n      },\r\n    ],\r\n    wallet,\r\n    connection,\r\n  });\r\n  for (let signedTransaction of signedTransactions) {\r\n    await sendSignedTransaction({\r\n      signedTransaction,\r\n      connection,\r\n    });\r\n  }\r\n\r\n  return market.publicKey;\r\n}\r\n\r\nexport const getUnixTs = () => {\r\n  return new Date().getTime() / 1000;\r\n};\r\n\r\nconst DEFAULT_TIMEOUT = 15000;\r\n\r\nexport async function sendTransaction({\r\n  transaction,\r\n  wallet,\r\n  signers = [],\r\n  connection,\r\n  sendingMessage = 'Sending transaction...',\r\n  sentMessage = 'Transaction sent',\r\n  successMessage = 'Transaction confirmed',\r\n  timeout = DEFAULT_TIMEOUT,\r\n  sendNotification = true,\r\n}: {\r\n  transaction: Transaction;\r\n  wallet: WalletAdapter;\r\n  signers?: Array<Account>;\r\n  connection: Connection;\r\n  sendingMessage?: string;\r\n  sentMessage?: string;\r\n  successMessage?: string;\r\n  timeout?: number;\r\n  sendNotification?: boolean;\r\n}) {\r\n  const signedTransaction = await signTransaction({\r\n    transaction,\r\n    wallet,\r\n    signers,\r\n    connection,\r\n  });\r\n  return await sendSignedTransaction({\r\n    signedTransaction,\r\n    connection,\r\n    sendingMessage,\r\n    sentMessage,\r\n    successMessage,\r\n    timeout,\r\n    sendNotification,\r\n  });\r\n}\r\n\r\nexport async function signTransaction({\r\n  transaction,\r\n  wallet,\r\n  signers = [],\r\n  connection,\r\n}: {\r\n  transaction: Transaction;\r\n  wallet: WalletAdapter;\r\n  signers?: Array<Account>;\r\n  connection: Connection;\r\n}) {\r\n  transaction.recentBlockhash = (\r\n    await connection.getRecentBlockhash('max')\r\n  ).blockhash;\r\n  transaction.setSigners(wallet.publicKey, ...signers.map((s) => s.publicKey));\r\n  if (signers.length > 0) {\r\n    transaction.partialSign(...signers);\r\n  }\r\n  return await wallet.signTransaction(transaction);\r\n}\r\n\r\nexport async function signTransactions({\r\n  transactionsAndSigners,\r\n  wallet,\r\n  connection,\r\n}: {\r\n  transactionsAndSigners: {\r\n    transaction: Transaction;\r\n    signers?: Array<Account>;\r\n  }[];\r\n  wallet: WalletAdapter;\r\n  connection: Connection;\r\n}) {\r\n  const blockhash = (await connection.getRecentBlockhash('max')).blockhash;\r\n  transactionsAndSigners.forEach(({ transaction, signers = [] }) => {\r\n    transaction.recentBlockhash = blockhash;\r\n    transaction.setSigners(\r\n      wallet.publicKey,\r\n      ...signers.map((s) => s.publicKey),\r\n    );\r\n    if (signers?.length > 0) {\r\n      transaction.partialSign(...signers);\r\n    }\r\n  });\r\n  return await wallet.signAllTransactions(\r\n    transactionsAndSigners.map(({ transaction }) => transaction),\r\n  );\r\n}\r\n\r\nexport async function sendSignedTransaction({\r\n  signedTransaction,\r\n  connection,\r\n  sendingMessage = 'Sending transaction...',\r\n  sentMessage = 'Transaction sent',\r\n  successMessage = 'Transaction confirmed',\r\n  timeout = DEFAULT_TIMEOUT,\r\n  sendNotification = true,\r\n}: {\r\n  signedTransaction: Transaction;\r\n  connection: Connection;\r\n  sendingMessage?: string;\r\n  sentMessage?: string;\r\n  successMessage?: string;\r\n  timeout?: number;\r\n  sendNotification?: boolean;\r\n}): Promise<string> {\r\n  const rawTransaction = signedTransaction.serialize();\r\n  const startTime = getUnixTs();\r\n  if (sendNotification) {\r\n    notify({ message: sendingMessage });\r\n  }\r\n  const txid: TransactionSignature = await connection.sendRawTransaction(\r\n    rawTransaction,\r\n    {\r\n      skipPreflight: true,\r\n    },\r\n  );\r\n  if (sendNotification) {\r\n    notify({ message: sentMessage, type: 'success', txid });\r\n  }\r\n\r\n  console.log('Started awaiting confirmation for', txid);\r\n\r\n  let done = false;\r\n  (async () => {\r\n    while (!done && getUnixTs() - startTime < timeout) {\r\n      connection.sendRawTransaction(rawTransaction, {\r\n        skipPreflight: true,\r\n      });\r\n      await sleep(300);\r\n    }\r\n  })();\r\n  try {\r\n    await awaitTransactionSignatureConfirmation(txid, timeout, connection);\r\n  } catch (err) {\r\n    if (err.timeout) {\r\n      throw new Error('Timed out awaiting confirmation on transaction');\r\n    }\r\n    let simulateResult: SimulatedTransactionResponse | null = null;\r\n    try {\r\n      simulateResult = (\r\n        await simulateTransaction(connection, signedTransaction, 'single')\r\n      ).value;\r\n    } catch (e) { }\r\n    if (simulateResult && simulateResult.err) {\r\n      if (simulateResult.logs) {\r\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\r\n          const line = simulateResult.logs[i];\r\n          if (line.startsWith('Program log: ')) {\r\n            throw new Error(\r\n              'Transaction failed: ' + line.slice('Program log: '.length),\r\n            );\r\n          }\r\n        }\r\n      }\r\n      let parsedError;\r\n      if (\r\n        typeof simulateResult.err == 'object' &&\r\n        'InstructionError' in simulateResult.err\r\n      ) {\r\n        const parsedErrorInfo = parseInstructionErrorResponse(\r\n          signedTransaction,\r\n          simulateResult.err['InstructionError'],\r\n        );\r\n        parsedError = parsedErrorInfo.error;\r\n      } else {\r\n        parsedError = JSON.stringify(simulateResult.err);\r\n      }\r\n      throw new Error(parsedError);\r\n    }\r\n    throw new Error('Transaction failed');\r\n  } finally {\r\n    done = true;\r\n  }\r\n  if (sendNotification) {\r\n    notify({ message: successMessage, type: 'success', txid });\r\n  }\r\n\r\n  console.log('Latency', txid, getUnixTs() - startTime);\r\n  return txid;\r\n}\r\n\r\nasync function awaitTransactionSignatureConfirmation(\r\n  txid: TransactionSignature,\r\n  timeout: number,\r\n  connection: Connection,\r\n) {\r\n  let done = false;\r\n  const result = await new Promise((resolve, reject) => {\r\n    (async () => {\r\n      setTimeout(() => {\r\n        if (done) {\r\n          return;\r\n        }\r\n        done = true;\r\n        console.log('Timed out for txid', txid);\r\n        reject({ timeout: true });\r\n      }, timeout);\r\n      try {\r\n        connection.onSignature(\r\n          txid,\r\n          (result) => {\r\n            console.log('WS confirmed', txid, result);\r\n            done = true;\r\n            if (result.err) {\r\n              reject(result.err);\r\n            } else {\r\n              resolve(result);\r\n            }\r\n          },\r\n          'recent',\r\n        );\r\n        console.log('Set up WS connection', txid);\r\n      } catch (e) {\r\n        done = true;\r\n        console.log('WS error in setup', txid, e);\r\n      }\r\n      while (!done) {\r\n        // eslint-disable-next-line no-loop-func\r\n        (async () => {\r\n          try {\r\n            const signatureStatuses = await connection.getSignatureStatuses([\r\n              txid,\r\n            ]);\r\n            const result = signatureStatuses && signatureStatuses.value[0];\r\n            if (!done) {\r\n              if (!result) {\r\n                console.log('REST null result for', txid, result);\r\n              } else if (result.err) {\r\n                console.log('REST error for', txid, result);\r\n                done = true;\r\n                reject(result.err);\r\n              } else if (!result.confirmations) {\r\n                console.log('REST no confirmations for', txid, result);\r\n              } else {\r\n                console.log('REST confirmation for', txid, result);\r\n                done = true;\r\n                resolve(result);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            if (!done) {\r\n              console.log('REST connection error: txid', txid, e);\r\n            }\r\n          }\r\n        })();\r\n        await sleep(300);\r\n      }\r\n    })();\r\n  });\r\n  done = true;\r\n  return result;\r\n}\r\n\r\nfunction mergeTransactions(transactions: (Transaction | undefined)[]) {\r\n  const transaction = new Transaction();\r\n  transactions\r\n    .filter((t): t is Transaction => t !== undefined)\r\n    .forEach((t) => {\r\n      transaction.add(t);\r\n    });\r\n  return transaction;\r\n}\r\n\r\nfunction jsonRpcResult(resultDescription: any) {\r\n  const jsonRpcVersion = struct.literal('2.0');\r\n  return struct.union([\r\n    struct({\r\n      jsonrpc: jsonRpcVersion,\r\n      id: 'string',\r\n      error: 'any',\r\n    }),\r\n    struct({\r\n      jsonrpc: jsonRpcVersion,\r\n      id: 'string',\r\n      error: 'null?',\r\n      result: resultDescription,\r\n    }),\r\n  ]);\r\n}\r\n\r\nfunction jsonRpcResultAndContext(resultDescription: any) {\r\n  return jsonRpcResult({\r\n    context: struct({\r\n      slot: 'number',\r\n    }),\r\n    value: resultDescription,\r\n  });\r\n}\r\n\r\nconst AccountInfoResult = struct({\r\n  executable: 'boolean',\r\n  owner: 'string',\r\n  lamports: 'number',\r\n  data: 'any',\r\n  rentEpoch: 'number?',\r\n});\r\n\r\nexport const GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(\r\n  struct.array([struct.union(['null', AccountInfoResult])]),\r\n);\r\n\r\nexport async function getMultipleSolanaAccounts(\r\n  connection: Connection,\r\n  publicKeys: PublicKey[],\r\n): Promise<\r\n  RpcResponseAndContext<{ [key: string]: AccountInfo<Buffer> | null }>\r\n> {\r\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: 'recent' }];\r\n  // @ts-ignore\r\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\r\n  const res = GetMultipleAccountsAndContextRpcResult(unsafeRes);\r\n  if (res.error) {\r\n    throw new Error(\r\n      'failed to get info about accounts ' +\r\n      publicKeys.map((k) => k.toBase58()).join(', ') +\r\n      ': ' +\r\n      res.error.message,\r\n    );\r\n  }\r\n  assert(typeof res.result !== 'undefined');\r\n  const accounts: Array<{\r\n    executable: any;\r\n    owner: PublicKey;\r\n    lamports: any;\r\n    data: Buffer;\r\n  } | null> = [];\r\n  for (const account of res.result.value) {\r\n    let value: {\r\n      executable: any;\r\n      owner: PublicKey;\r\n      lamports: any;\r\n      data: Buffer;\r\n    } | null = null;\r\n    if (res.result.value) {\r\n      const { executable, owner, lamports, data } = account;\r\n      assert(data[1] === 'base64');\r\n      value = {\r\n        executable,\r\n        owner: new PublicKey(owner),\r\n        lamports,\r\n        data: Buffer.from(data[0], 'base64'),\r\n      };\r\n    }\r\n    accounts.push(value);\r\n  }\r\n  return {\r\n    context: {\r\n      slot: res.result.context.slot,\r\n    },\r\n    value: Object.fromEntries(\r\n      accounts.map((account, i) => [publicKeys[i].toBase58(), account]),\r\n    ),\r\n  };\r\n}\r\n\r\n/** Copy of Connection.simulateTransaction that takes a commitment parameter. */\r\nasync function simulateTransaction(\r\n  connection: Connection,\r\n  transaction: Transaction,\r\n  commitment: Commitment,\r\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\r\n  // @ts-ignore\r\n  transaction.recentBlockhash = await connection._recentBlockhash(\r\n    // @ts-ignore\r\n    connection._disableBlockhashCaching,\r\n  );\r\n\r\n  const signData = transaction.serializeMessage();\r\n  // @ts-ignore\r\n  const wireTransaction = transaction._serialize(signData);\r\n  const encodedTransaction = wireTransaction.toString('base64');\r\n  const config: any = { encoding: 'base64', commitment };\r\n  const args = [encodedTransaction, config];\r\n\r\n  // @ts-ignore\r\n  const res = await connection._rpcRequest('simulateTransaction', args);\r\n  if (res.error) {\r\n    throw new Error('failed to simulate transaction: ' + res.error.message);\r\n  }\r\n  return res.result;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}