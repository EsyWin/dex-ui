{"ast":null,"code":"var _jsxFileName = \"/home/dev/Code/dex-ui/src/utils/markets.tsx\";\nimport { // MARKETS,\nMarket, OpenOrders, Orderbook, TOKEN_MINTS, TokenInstructions } from '@project-serum/serum';\nimport React, { useContext, useEffect, useState } from 'react';\nimport { getCache, setCache } from './fetch-loop';\nimport { divideBnToNumber, floorToDecimal, getTokenMultiplierFromDecimals, useLocalStorageState } from './utils';\nimport { getTokenAccountInfo, parseTokenAccountData, TOKENS, useMintInfos } from './tokens';\nimport { refreshCache, useAsyncData } from './fetch-loop';\nimport { useAccountData, useAccountInfo, useConnection } from './connection';\nimport BN from 'bn.js';\nimport RaydiumApi from './raydiumConnector';\nimport { PublicKey } from '@solana/web3.js';\nimport { WRAPPED_SOL_MINT } from '@project-serum/serum/lib/token-instructions';\nimport { notify } from './notifications';\nimport { sleep } from './utils';\nimport tuple from 'immutable-tuple';\nimport { useWallet } from './wallet'; // Used in debugging, should be false in production\n\nconst _IGNORE_DEPRECATED = false;\nconst _MARKETS = [{\n  name: 'RAY/soUSDT',\n  deprecated: true,\n  address: new PublicKey('C4z32zw9WKaGPhNuU54ohzrV4CE1Uau3cFx6T8RLjxYC'),\n  programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')\n}, {\n  name: 'RAY/USDC',\n  deprecated: false,\n  address: new PublicKey('2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep'),\n  programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')\n}, {\n  name: 'RAY/USDT',\n  deprecated: false,\n  address: new PublicKey('teE55QrL4a4QSfydR9dnHF97jgCfptpuigbb53Lo95g'),\n  programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')\n}, {\n  name: 'RAY/SRM',\n  deprecated: false,\n  address: new PublicKey('Cm4MmknScg7qbKqytb1mM92xgDxv3TNXos4tKbBqTDy7'),\n  programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')\n}, {\n  name: 'RAY/SOL',\n  deprecated: false,\n  address: new PublicKey('C6tp2RVZnxBPFbnAsfTjis8BN9tycESAT4SgDQgbbrsA'),\n  programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')\n}, {\n  name: 'RAY/soETH',\n  deprecated: false,\n  address: new PublicKey('6jx6aoNFbmorwyncVP5V5ESKfuFc9oUYebob1iF6tgN4'),\n  programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin')\n} // ...MARKETS,\n]; // MARKETS.forEach(item => {\n//   if (item.address.toBase58() === '5GAPymgnnWieGcRrcghZdA3aanefqa4cZx1ZSE8UTyMV') return\n//   if (_MARKETS.find(oldMarket => oldMarket.address.toBase58() === item.address.toBase58())) return\n//   if (item.address.toBase58() === '7MpMwArporUHEGW7quUpkPZp5L5cHPs9eKUfKCdaPHq2') {\n//     _MARKETS.push( {\n//       address: item.address,\n//       name: 'xCOPE/USDC',\n//       programId: item.programId,\n//       deprecated: item.deprecated,\n//     })\n//     return\n//   }\n//   _MARKETS.push(item)\n// })\n\nexport const USE_MARKETS = _IGNORE_DEPRECATED ? _MARKETS.map(m => ({ ...m,\n  deprecated: false\n})) : _MARKETS;\nexport function useMarketsList() {\n  return USE_MARKETS.filter(({\n    deprecated\n  }) => !deprecated);\n}\nexport function useAllMarkets() {\n  const connection = useConnection();\n  const {\n    customMarkets\n  } = useCustomMarkets();\n\n  const getAllMarkets = async () => {\n    const markets = await Promise.all(getMarketInfos(customMarkets).map(async marketInfo => {\n      try {\n        const market = await Market.load(connection, marketInfo.address, {}, marketInfo.programId);\n        return {\n          market,\n          marketName: marketInfo.name,\n          programId: marketInfo.programId\n        };\n      } catch (e) {\n        notify({\n          message: 'Error loading all market',\n          description: e.message,\n          type: 'error'\n        });\n        return null;\n      }\n    }));\n    return markets.filter(m => !!m);\n  };\n\n  return useAsyncData(getAllMarkets, tuple('getAllMarkets', customMarkets.length, connection), {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useUnmigratedOpenOrdersAccounts() {\n  var _wallet$publicKey;\n\n  const connection = useConnection();\n  const {\n    wallet\n  } = useWallet();\n\n  async function getUnmigratedOpenOrdersAccounts() {\n    if (!wallet || !connection || !wallet.publicKey) {\n      return [];\n    }\n\n    console.log('refreshing useUnmigratedOpenOrdersAccounts');\n    let deprecatedOpenOrdersAccounts = [];\n    const deprecatedProgramIds = Array.from(new Set(USE_MARKETS.filter(({\n      deprecated\n    }) => deprecated).map(({\n      programId\n    }) => programId.toBase58()))).map(publicKeyStr => new PublicKey(publicKeyStr));\n    let programId;\n\n    for (programId of deprecatedProgramIds) {\n      try {\n        const openOrdersAccounts = await OpenOrders.findForOwner(connection, wallet.publicKey, programId);\n        deprecatedOpenOrdersAccounts = deprecatedOpenOrdersAccounts.concat(openOrdersAccounts.filter(openOrders => openOrders.baseTokenTotal.toNumber() || openOrders.quoteTokenTotal.toNumber()).filter(openOrders => USE_MARKETS.some(market => market.deprecated && market.address.equals(openOrders.market))));\n      } catch (e) {\n        var _programId;\n\n        console.log('Error loading deprecated markets', (_programId = programId) === null || _programId === void 0 ? void 0 : _programId.toBase58(), e.message);\n      }\n    } // Maybe sort\n\n\n    return deprecatedOpenOrdersAccounts;\n  }\n\n  const cacheKey = tuple('getUnmigratedOpenOrdersAccounts', connection, wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58());\n  const [accounts] = useAsyncData(getUnmigratedOpenOrdersAccounts, cacheKey, {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n  return {\n    accounts,\n    refresh: clearCache => refreshCache(cacheKey, clearCache)\n  };\n}\nconst MarketContext = React.createContext(null);\n\nconst _VERY_SLOW_REFRESH_INTERVAL = 5000 * 1000; // For things that don't really change\n\n\nconst _SLOW_REFRESH_INTERVAL = 5 * 1000;\n\nconst _SLOW_REFRESH_INTERVAL_NEW = 60 * 1000; // For things that change frequently\n\n\nconst _FAST_REFRESH_INTERVAL = 1000;\nexport const DEFAULT_MARKET = USE_MARKETS.find(({\n  name,\n  deprecated\n}) => name === 'RAY/USDC' && !deprecated);\nexport function getMarketDetails(market, customMarkets) {\n  var _TOKEN_MINTS$find, _TOKEN_MINTS$find2;\n\n  if (!market) {\n    return {};\n  }\n\n  const marketInfos = getMarketInfos(customMarkets);\n  const marketInfo = marketInfos.find(otherMarket => otherMarket.address.equals(market.address)); // add new token here\n  // TOKEN_MINTS.push({\n  //   address: new PublicKey('4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R'),\n  //   name: 'RAY',\n  // });\n\n  for (let indexItem = 0; indexItem < TOKEN_MINTS.length; indexItem += 1) {\n    if (TOKEN_MINTS[indexItem].address.toString() === '3K6rftdAaQYMPunrtNRHgnK2UAtjm2JwyT2oCiTDouYE') {\n      TOKEN_MINTS[indexItem].name = 'xCOPE';\n    }\n  }\n\n  Object.values(TOKENS).forEach(itemToken => {\n    if (!TOKEN_MINTS.find(item => item.address.toString === itemToken.mintAddress)) {\n      TOKEN_MINTS.push({\n        address: new PublicKey(itemToken.mintAddress),\n        name: itemToken.symbol\n      });\n    }\n  });\n  const baseCurrency = (market === null || market === void 0 ? void 0 : market.baseMintAddress) && ((_TOKEN_MINTS$find = TOKEN_MINTS.find(token => token.address.equals(market.baseMintAddress))) === null || _TOKEN_MINTS$find === void 0 ? void 0 : _TOKEN_MINTS$find.name) || (marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.baseLabel) && `${marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.baseLabel}*` || 'UNKNOWN';\n  const quoteCurrency = (market === null || market === void 0 ? void 0 : market.quoteMintAddress) && ((_TOKEN_MINTS$find2 = TOKEN_MINTS.find(token => token.address.equals(market.quoteMintAddress))) === null || _TOKEN_MINTS$find2 === void 0 ? void 0 : _TOKEN_MINTS$find2.name) || (marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.quoteLabel) && `${marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.quoteLabel}*` || 'UNKNOWN';\n  return { ...marketInfo,\n    marketName: marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.name,\n    baseCurrency,\n    quoteCurrency,\n    marketInfo\n  };\n}\nexport function useCustomMarkets() {\n  const [customMarkets, setCustomMarkets] = useLocalStorageState('customMarkets', []);\n  return {\n    customMarkets,\n    setCustomMarkets\n  };\n}\nexport function MarketProvider({\n  marketAddress,\n  setMarketAddress,\n  children\n}) {\n  const {\n    customMarkets,\n    setCustomMarkets\n  } = useCustomMarkets();\n  const address = marketAddress && new PublicKey(marketAddress);\n  const connection = useConnection();\n  const marketInfos = getMarketInfos(customMarkets);\n  const marketInfo = address && marketInfos.find(market => market.address.equals(address));\n  const [market, setMarket] = useState();\n  const [marketName, setMarketName] = useState('RAY/USDT');\n  const [localToken, setLocalToken] = useState(false);\n  const [localMarket, setLocalMarket] = useState(false);\n  useEffect(() => {\n    const fetchMarket = async () => {\n      const data = await fetch('https://api.raydium.io/v1/dex/market');\n      const json = await data.json();\n      return json;\n    };\n\n    fetchMarket().then(json => {\n      var _data;\n\n      window.localStorage.setItem('apiMarket', JSON.stringify(json));\n      const marketData = (_data = (json !== null && json !== void 0 ? json : {}).data) !== null && _data !== void 0 ? _data : {};\n\n      for (const [programId, marketDict] of Object.entries(marketData)) {\n        for (const [itemMarket, marketName] of Object.entries(marketDict)) {\n          if (!_MARKETS.find(item => item.address.toString() === itemMarket)) {\n            _MARKETS.push({\n              name: marketName,\n              deprecated: false,\n              address: new PublicKey(itemMarket),\n              programId: new PublicKey(programId)\n            });\n          }\n        }\n      }\n\n      console.log('load market over');\n      setLocalMarket(true);\n    });\n  }, []);\n  useEffect(() => {\n    const localMarket = window.localStorage.getItem('apiMarket');\n\n    try {\n      var _data2, _JSON$parse;\n\n      if (localMarket === null) {\n        console.log('no local market');\n        return;\n      }\n\n      const marketData = (_data2 = ((_JSON$parse = JSON.parse(localMarket)) !== null && _JSON$parse !== void 0 ? _JSON$parse : {}).data) !== null && _data2 !== void 0 ? _data2 : {};\n\n      for (const [programId, marketDict] of Object.entries(marketData)) {\n        for (const [itemMarket, marketName] of Object.entries(marketDict)) {\n          if (!_MARKETS.find(item => item.address.toString() === itemMarket)) {\n            _MARKETS.push({\n              name: marketName,\n              deprecated: false,\n              address: new PublicKey(itemMarket),\n              programId: new PublicKey(programId)\n            });\n          }\n        }\n      }\n\n      console.log('local market over');\n      setLocalMarket(true);\n    } catch (e) {\n      console.error('local market error', e);\n    }\n  }, []);\n  useEffect(() => {\n    const fetchToken = async () => {\n      const data = await fetch('https://api.raydium.io/v1/dex/token');\n      const json = await data.json();\n      return json;\n    };\n\n    fetchToken().then(json => {\n      var _data3;\n\n      window.localStorage.setItem('apiToken', JSON.stringify(json));\n      const tokenData = (_data3 = (json !== null && json !== void 0 ? json : {}).data) !== null && _data3 !== void 0 ? _data3 : {};\n\n      for (const [mint, symbol] of Object.entries(tokenData)) {\n        if (TOKENS[mint] === undefined || !Object.values(TOKENS).find(item => item.mintAddress === mint)) {\n          TOKENS[mint] = {\n            symbol,\n            mintAddress: mint\n          };\n        }\n      }\n\n      setLocalToken(true);\n      console.log('load token over');\n    });\n  }, []);\n  useEffect(() => {\n    const localToken = window.localStorage.getItem('apiToken');\n\n    try {\n      var _data4;\n\n      if (localToken === null) {\n        console.log('no local token');\n        return;\n      }\n\n      const json = JSON.parse(localToken);\n      const tokenData = (_data4 = (json !== null && json !== void 0 ? json : {}).data) !== null && _data4 !== void 0 ? _data4 : {};\n\n      for (const [mint, symbol] of Object.entries(tokenData)) {\n        if (TOKENS[mint] === undefined || !Object.values(TOKENS).find(item => item.mintAddress === mint)) {\n          TOKENS[mint] = {\n            symbol,\n            mintAddress: mint\n          };\n        }\n      }\n\n      setLocalToken(true);\n      console.log('local token over');\n    } catch (e) {\n      console.error('local token error', e);\n    }\n  }, []); // Replace existing market with a non-deprecated one on first load\n\n  useEffect(() => {\n    if (marketInfo) {\n      if (marketInfo.deprecated) {\n        console.log('Switching markets from deprecated', marketInfo);\n\n        if (DEFAULT_MARKET) {\n          // setMarketAddress(DEFAULT_MARKET.address.toBase58());\n          setMarketAddress('2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep');\n        }\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(() => {\n    var _market$_decoded$ownA;\n\n    if (market && marketInfo && ( // @ts-ignore\n    (_market$_decoded$ownA = market._decoded.ownAddress) === null || _market$_decoded$ownA === void 0 ? void 0 : _market$_decoded$ownA.equals(marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.address))) {\n      return;\n    }\n\n    if (!localMarket || !localToken) return;\n    setMarket(null);\n\n    if (!marketInfo || !marketInfo.address) {\n      notify({\n        message: 'Error loading market',\n        description: 'Please select a market from the dropdown',\n        type: 'error'\n      });\n      return;\n    } else {\n      setMarketName(marketInfo.name);\n    }\n\n    Market.load(connection, marketInfo.address, {}, marketInfo.programId).then(setMarket).catch(e => notify({\n      message: 'Error loading market',\n      description: e.message,\n      type: 'error'\n    })); // eslint-disable-next-line\n  }, [connection, marketInfo, USE_MARKETS, localMarket, localToken]);\n  return /*#__PURE__*/React.createElement(MarketContext.Provider, {\n    value: {\n      market,\n      ...getMarketDetails(market, customMarkets),\n      setMarketAddress,\n      customMarkets,\n      setCustomMarkets,\n      marketName\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 488,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function getTradePageUrl(marketAddress) {\n  if (!marketAddress) {\n    const saved = localStorage.getItem('marketAddress');\n\n    if (saved) {\n      marketAddress = JSON.parse(saved);\n    }\n\n    marketAddress = marketAddress || (DEFAULT_MARKET === null || DEFAULT_MARKET === void 0 ? void 0 : DEFAULT_MARKET.address.toBase58()) || '2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep';\n  }\n\n  return `/market/${marketAddress}`;\n}\nexport function useSelectedTokenAccounts() {\n  const [selectedTokenAccounts, setSelectedTokenAccounts] = useLocalStorageState('selectedTokenAccounts', {});\n  return [selectedTokenAccounts, setSelectedTokenAccounts];\n}\nexport function useMarket() {\n  const context = useContext(MarketContext);\n\n  if (!context) {\n    throw new Error('Missing market context');\n  }\n\n  return context;\n}\nexport function useMarkPrice() {\n  const [markPrice, setMarkPrice] = useState(null);\n  const [orderbook] = useOrderbook();\n  const trades = useTrades();\n  useEffect(() => {\n    var _orderbook$bids, _orderbook$asks;\n\n    let bb = (orderbook === null || orderbook === void 0 ? void 0 : (_orderbook$bids = orderbook.bids) === null || _orderbook$bids === void 0 ? void 0 : _orderbook$bids.length) > 0 && Number(orderbook.bids[0][0]);\n    let ba = (orderbook === null || orderbook === void 0 ? void 0 : (_orderbook$asks = orderbook.asks) === null || _orderbook$asks === void 0 ? void 0 : _orderbook$asks.length) > 0 && Number(orderbook.asks[0][0]);\n    let last = trades && trades.length > 0 && trades[0].price;\n    let markPrice = bb && ba ? last ? [bb, ba, last].sort((a, b) => a - b)[1] : (bb + ba) / 2 : null;\n    setMarkPrice(markPrice);\n  }, [orderbook, trades]);\n  return markPrice;\n}\nexport function _useUnfilteredTrades(limit = 10000) {\n  const {\n    market\n  } = useMarket();\n  const connection = useConnection();\n\n  async function getUnfilteredTrades() {\n    if (!market || !connection) {\n      return null;\n    }\n\n    return await market.loadFills(connection, limit);\n  }\n\n  const [trades] = useAsyncData(getUnfilteredTrades, tuple('getUnfilteredTrades', market, connection), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n  return trades; // NOTE: For now, websocket is too expensive since the event queue is large\n  // and updates very frequently\n  // let data = useAccountData(market && market._decoded.eventQueue);\n  // if (!data) {\n  //   return null;\n  // }\n  // const events = decodeEventQueue(data, limit);\n  // return events\n  //   .filter((event) => event.eventFlags.fill && event.nativeQuantityPaid.gtn(0))\n  //   .map(market.parseFillEvent.bind(market));\n}\nexport function useRaydiumTrades() {\n  const {\n    market\n  } = useMarket();\n  const marketAddress = market === null || market === void 0 ? void 0 : market.address.toBase58();\n\n  async function getRaydiumTrades() {\n    if (!marketAddress) {\n      return null;\n    }\n\n    return await RaydiumApi.getRecentTrades(marketAddress);\n  }\n\n  return useAsyncData(getRaydiumTrades, tuple('getRaydiumTrades', marketAddress), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL_NEW\n  }, false);\n}\nexport function useOrderbookAccounts() {\n  const {\n    market\n  } = useMarket(); // @ts-ignore\n\n  let bidData = useAccountData(market && market._decoded.bids); // @ts-ignore\n\n  let askData = useAccountData(market && market._decoded.asks);\n  return {\n    bidOrderbook: market && bidData ? Orderbook.decode(market, bidData) : null,\n    askOrderbook: market && askData ? Orderbook.decode(market, askData) : null\n  };\n}\nexport function useOrderbook(depth = 20) {\n  const {\n    bidOrderbook,\n    askOrderbook\n  } = useOrderbookAccounts();\n  const {\n    market\n  } = useMarket();\n  const bids = !bidOrderbook || !market ? [] : bidOrderbook.getL2(depth).map(([price, size]) => [price, size]);\n  const asks = !askOrderbook || !market ? [] : askOrderbook.getL2(depth).map(([price, size]) => [price, size]);\n  return [{\n    bids,\n    asks\n  }, !!bids || !!asks];\n} // Want the balances table to be fast-updating, dont want open orders to flicker\n// TODO: Update to use websocket\n\nexport function useOpenOrdersAccounts(fast = false) {\n  const {\n    market\n  } = useMarket();\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const connection = useConnection();\n\n  async function getOpenOrdersAccounts() {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    if (!market) {\n      return null;\n    }\n\n    return await market.findOpenOrdersAccountsForOwner(connection, wallet.publicKey);\n  }\n\n  return useAsyncData(getOpenOrdersAccounts, tuple('getOpenOrdersAccounts', wallet, market, connected), {\n    refreshInterval: fast ? _FAST_REFRESH_INTERVAL : _SLOW_REFRESH_INTERVAL\n  });\n} // todo: refresh cache after some time?\n\nexport async function getCachedMarket(connection, address, programId) {\n  let market;\n  const cacheKey = tuple('getCachedMarket', 'market', address.toString(), connection);\n\n  if (!getCache(cacheKey)) {\n    market = await Market.load(connection, address, {}, programId);\n    setCache(cacheKey, market);\n  } else {\n    market = getCache(cacheKey);\n  }\n\n  return market;\n}\nexport async function getCachedOpenOrderAccounts(connection, market, owner) {\n  let accounts;\n  const cacheKey = tuple('getCachedOpenOrderAccounts', market.address.toString(), owner.toString(), connection);\n\n  if (!getCache(cacheKey)) {\n    accounts = await market.findOpenOrdersAccountsForOwner(connection, owner);\n    setCache(cacheKey, accounts);\n  } else {\n    accounts = getCache(cacheKey);\n  }\n\n  return accounts;\n}\nexport function useSelectedOpenOrdersAccount(fast = false) {\n  const [accounts] = useOpenOrdersAccounts(fast);\n\n  if (!accounts) {\n    return null;\n  }\n\n  return accounts[0];\n}\nexport function useTokenAccounts() {\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const connection = useConnection();\n\n  async function getTokenAccounts() {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    return await getTokenAccountInfo(connection, wallet.publicKey);\n  }\n\n  return useAsyncData(getTokenAccounts, tuple('getTokenAccounts', wallet, connected), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function getSelectedTokenAccountForMint(accounts, mint, selectedPubKey) {\n  if (!accounts || !mint) {\n    return null;\n  }\n\n  const filtered = accounts.filter(({\n    effectiveMint,\n    pubkey\n  }) => mint.equals(effectiveMint) && (!selectedPubKey || (typeof selectedPubKey === 'string' ? selectedPubKey : selectedPubKey.toBase58()) === pubkey.toBase58()));\n  return filtered && filtered[0];\n}\nexport function useSelectedQuoteCurrencyAccount() {\n  const [accounts] = useTokenAccounts();\n  const {\n    market\n  } = useMarket();\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\n  const mintAddress = market === null || market === void 0 ? void 0 : market.quoteMintAddress;\n  return getSelectedTokenAccountForMint(accounts, mintAddress, mintAddress && selectedTokenAccounts[mintAddress.toBase58()]);\n}\nexport function useSelectedBaseCurrencyAccount() {\n  const [accounts] = useTokenAccounts();\n  const {\n    market\n  } = useMarket();\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\n  const mintAddress = market === null || market === void 0 ? void 0 : market.baseMintAddress;\n  return getSelectedTokenAccountForMint(accounts, mintAddress, mintAddress && selectedTokenAccounts[mintAddress.toBase58()]);\n} // TODO: Update to use websocket\n\nexport function useSelectedQuoteCurrencyBalances() {\n  const quoteCurrencyAccount = useSelectedQuoteCurrencyAccount();\n  const {\n    market\n  } = useMarket();\n  const [accountInfo, loaded] = useAccountInfo(quoteCurrencyAccount === null || quoteCurrencyAccount === void 0 ? void 0 : quoteCurrencyAccount.pubkey);\n\n  if (!market || !quoteCurrencyAccount || !loaded || !accountInfo) {\n    return null;\n  }\n\n  if (market.quoteMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\n    var _ref;\n\n    return (_ref = (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.lamports) / 1e9) !== null && _ref !== void 0 ? _ref : 0;\n  }\n\n  return market.quoteSplSizeToNumber(new BN(accountInfo.data.slice(64, 72), 10, 'le'));\n} // TODO: Update to use websocket\n\nexport function useSelectedBaseCurrencyBalances() {\n  const baseCurrencyAccount = useSelectedBaseCurrencyAccount();\n  const {\n    market\n  } = useMarket();\n  const [accountInfo, loaded] = useAccountInfo(baseCurrencyAccount === null || baseCurrencyAccount === void 0 ? void 0 : baseCurrencyAccount.pubkey);\n\n  if (!market || !baseCurrencyAccount || !loaded || !accountInfo) {\n    return null;\n  }\n\n  if (market.baseMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\n    var _ref2;\n\n    return (_ref2 = (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.lamports) / 1e9) !== null && _ref2 !== void 0 ? _ref2 : 0;\n  }\n\n  return market.baseSplSizeToNumber(new BN(accountInfo.data.slice(64, 72), 10, 'le'));\n}\nexport function useOpenOrders() {\n  const {\n    market,\n    marketName\n  } = useMarket();\n  const openOrdersAccount = useSelectedOpenOrdersAccount();\n  const {\n    bidOrderbook,\n    askOrderbook\n  } = useOrderbookAccounts();\n\n  if (!market || !openOrdersAccount || !bidOrderbook || !askOrderbook) {\n    return null;\n  }\n\n  return market.filterForOpenOrders(bidOrderbook, askOrderbook, [openOrdersAccount]).map(order => ({ ...order,\n    marketName,\n    market\n  }));\n}\nexport function useTrades(limit = 100) {\n  const trades = _useUnfilteredTrades(limit);\n\n  if (!trades) {\n    return null;\n  } // Until partial fills are each given their own fill, use maker fills\n\n\n  return trades.filter(({\n    eventFlags\n  }) => eventFlags.maker).map(trade => ({ ...trade,\n    side: trade.side === 'buy' ? 'sell' : 'buy'\n  }));\n}\nexport function useLocallyStoredFeeDiscountKey() {\n  const [storedFeeDiscountKey, setStoredFeeDiscountKey] = useLocalStorageState(`feeDiscountKey`, undefined);\n  return {\n    storedFeeDiscountKey: storedFeeDiscountKey ? new PublicKey(storedFeeDiscountKey) : undefined,\n    setStoredFeeDiscountKey\n  };\n}\nexport function useFeeDiscountKeys() {\n  const {\n    market\n  } = useMarket();\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const connection = useConnection();\n  const {\n    setStoredFeeDiscountKey\n  } = useLocallyStoredFeeDiscountKey();\n\n  let getFeeDiscountKeys = async () => {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    if (!market) {\n      return null;\n    }\n\n    const feeDiscountKey = await market.findFeeDiscountKeys(connection, wallet.publicKey);\n\n    if (feeDiscountKey) {\n      setStoredFeeDiscountKey(feeDiscountKey[0].pubkey.toBase58());\n    }\n\n    return feeDiscountKey;\n  };\n\n  return useAsyncData(getFeeDiscountKeys, tuple('getFeeDiscountKeys', wallet, market, connected), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useFills(limit = 100) {\n  const {\n    marketName\n  } = useMarket();\n\n  const fills = _useUnfilteredTrades(limit);\n\n  const [openOrdersAccounts] = useOpenOrdersAccounts();\n\n  if (!openOrdersAccounts || openOrdersAccounts.length === 0) {\n    return null;\n  }\n\n  if (!fills) {\n    return null;\n  }\n\n  return fills.filter(fill => openOrdersAccounts.some(openOrdersAccount => fill.openOrders.equals(openOrdersAccount.publicKey))).map(fill => ({ ...fill,\n    marketName\n  }));\n}\nexport function useAllOpenOrdersAccounts() {\n  var _wallet$publicKey2;\n\n  const {\n    wallet,\n    connected\n  } = useWallet();\n  const connection = useConnection();\n  const marketInfos = useMarketInfos();\n  const programIds = [...new Set(marketInfos.map(info => info.programId.toBase58()))].map(stringProgramId => new PublicKey(stringProgramId));\n\n  const getAllOpenOrdersAccounts = async () => {\n    if (!connected || !wallet) {\n      return [];\n    }\n\n    return (await Promise.all(programIds.map(programId => OpenOrders.findForOwner(connection, wallet.publicKey, programId)))).flat();\n  };\n\n  return useAsyncData(getAllOpenOrdersAccounts, tuple('getAllOpenOrdersAccounts', connection, connected, wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey2 = wallet.publicKey) === null || _wallet$publicKey2 === void 0 ? void 0 : _wallet$publicKey2.toBase58(), marketInfos.length, (programIds || []).length), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useAllOpenOrdersBalances() {\n  const [openOrdersAccounts, loadedOpenOrdersAccounts] = useAllOpenOrdersAccounts();\n  const [mintInfos, mintInfosConnected] = useMintInfos();\n  const [allMarkets] = useAllMarkets();\n\n  if (!loadedOpenOrdersAccounts || !mintInfosConnected) {\n    return {};\n  }\n\n  const marketsByAddress = Object.fromEntries((allMarkets || []).map(m => [m.market.address.toBase58(), m]));\n  const openOrdersBalances = {};\n\n  for (let account of openOrdersAccounts || []) {\n    const marketInfo = marketsByAddress[account.market.toBase58()];\n    const baseMint = marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.market.baseMintAddress.toBase58();\n    const quoteMint = marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.market.quoteMintAddress.toBase58();\n\n    if (!(baseMint in openOrdersBalances)) {\n      openOrdersBalances[baseMint] = [];\n    }\n\n    if (!(quoteMint in openOrdersBalances)) {\n      openOrdersBalances[quoteMint] = [];\n    }\n\n    const baseMintInfo = mintInfos && mintInfos[baseMint];\n    const baseFree = divideBnToNumber(new BN(account.baseTokenFree), getTokenMultiplierFromDecimals((baseMintInfo === null || baseMintInfo === void 0 ? void 0 : baseMintInfo.decimals) || 0));\n    const baseTotal = divideBnToNumber(new BN(account.baseTokenTotal), getTokenMultiplierFromDecimals((baseMintInfo === null || baseMintInfo === void 0 ? void 0 : baseMintInfo.decimals) || 0));\n    const quoteMintInfo = mintInfos && mintInfos[quoteMint];\n    const quoteFree = divideBnToNumber(new BN(account.quoteTokenFree), getTokenMultiplierFromDecimals((quoteMintInfo === null || quoteMintInfo === void 0 ? void 0 : quoteMintInfo.decimals) || 0));\n    const quoteTotal = divideBnToNumber(new BN(account.quoteTokenTotal), getTokenMultiplierFromDecimals((quoteMintInfo === null || quoteMintInfo === void 0 ? void 0 : quoteMintInfo.decimals) || 0));\n    openOrdersBalances[baseMint].push({\n      market: account.market,\n      free: baseFree,\n      total: baseTotal\n    });\n    openOrdersBalances[quoteMint].push({\n      market: account.market,\n      free: quoteFree,\n      total: quoteTotal\n    });\n  }\n\n  return openOrdersBalances;\n}\nexport const useAllOpenOrders = () => {\n  const connection = useConnection();\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const [loaded, setLoaded] = useState(false);\n  const [refresh, setRefresh] = useState(0);\n  const [openOrders, setOpenOrders] = useState(null);\n  const [lastRefresh, setLastRefresh] = useState(0);\n\n  const refreshOpenOrders = () => {\n    if (new Date().getTime() - lastRefresh > 10 * 1000) {\n      setRefresh(prev => prev + 1);\n    } else {\n      console.log('not refreshing');\n    }\n  };\n\n  useEffect(() => {\n    if (connected && wallet) {\n      const getAllOpenOrders = async () => {\n        setLoaded(false);\n        const _openOrders = [];\n\n        const getOpenOrdersForMarket = async marketInfo => {\n          await sleep(1000 * Math.random()); // Try not to hit rate limit\n\n          try {\n            const market = await Market.load(connection, marketInfo.address, undefined, marketInfo.programId);\n            const orders = await market.loadOrdersForOwner(connection, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, 30000);\n\n            _openOrders.push({\n              orders: orders,\n              marketAddress: marketInfo.address.toBase58()\n            });\n          } catch (e) {\n            console.warn(`Error loading open order ${marketInfo.name} - ${e}`);\n          }\n        };\n\n        await Promise.all(USE_MARKETS.map(m => getOpenOrdersForMarket(m)));\n        setOpenOrders(_openOrders);\n        setLastRefresh(new Date().getTime());\n        setLoaded(true);\n      };\n\n      getAllOpenOrders();\n    }\n  }, [connection, connected, wallet, refresh]);\n  return {\n    openOrders: openOrders,\n    loaded: loaded,\n    refreshOpenOrders: refreshOpenOrders\n  };\n};\nexport function useBalances() {\n  const baseCurrencyBalances = useSelectedBaseCurrencyBalances();\n  const quoteCurrencyBalances = useSelectedQuoteCurrencyBalances();\n  const openOrders = useSelectedOpenOrdersAccount(true);\n  const {\n    baseCurrency,\n    quoteCurrency,\n    market\n  } = useMarket();\n  const baseExists = openOrders && openOrders.baseTokenTotal && openOrders.baseTokenFree;\n  const quoteExists = openOrders && openOrders.quoteTokenTotal && openOrders.quoteTokenFree;\n\n  if (baseCurrency === 'UNKNOWN' || quoteCurrency === 'UNKNOWN' || !baseCurrency || !quoteCurrency) {\n    return [];\n  }\n\n  return [{\n    market,\n    key: `${baseCurrency}${quoteCurrency}${baseCurrency}`,\n    coin: baseCurrency,\n    wallet: baseCurrencyBalances,\n    orders: baseExists && market && openOrders ? market.baseSplSizeToNumber(openOrders.baseTokenTotal.sub(openOrders.baseTokenFree)) : null,\n    openOrders,\n    unsettled: baseExists && market && openOrders ? market.baseSplSizeToNumber(openOrders.baseTokenFree) : null\n  }, {\n    market,\n    key: `${quoteCurrency}${baseCurrency}${quoteCurrency}`,\n    coin: quoteCurrency,\n    wallet: quoteCurrencyBalances,\n    openOrders,\n    orders: quoteExists && market && openOrders ? market.quoteSplSizeToNumber(openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree)) : null,\n    unsettled: quoteExists && market && openOrders ? market.quoteSplSizeToNumber(openOrders.quoteTokenFree) : null\n  }];\n}\nexport function useWalletBalancesForAllMarkets() {\n  const [tokenAccounts] = useTokenAccounts();\n  const {\n    connected\n  } = useWallet();\n  const [mintInfos, mintInfosConnected] = useMintInfos();\n\n  if (!connected || !mintInfosConnected) {\n    return [];\n  }\n\n  let balances = {};\n\n  for (let account of tokenAccounts || []) {\n    if (!account.account) {\n      continue;\n    }\n\n    let parsedAccount;\n\n    if (account.effectiveMint.equals(WRAPPED_SOL_MINT)) {\n      parsedAccount = {\n        mint: WRAPPED_SOL_MINT,\n        owner: account.pubkey,\n        amount: account.account.lamports\n      };\n    } else {\n      parsedAccount = parseTokenAccountData(account.account.data);\n    }\n\n    if (!(parsedAccount.mint.toBase58() in balances)) {\n      balances[parsedAccount.mint.toBase58()] = 0;\n    }\n\n    const mintInfo = mintInfos && mintInfos[parsedAccount.mint.toBase58()];\n    const additionalAmount = divideBnToNumber(new BN(parsedAccount.amount), getTokenMultiplierFromDecimals((mintInfo === null || mintInfo === void 0 ? void 0 : mintInfo.decimals) || 0));\n    balances[parsedAccount.mint.toBase58()] += additionalAmount;\n  }\n\n  return Object.entries(balances).map(([mint, balance]) => {\n    return {\n      mint,\n      balance\n    };\n  });\n}\nexport function useUnmigratedDeprecatedMarkets() {\n  const connection = useConnection();\n  const {\n    accounts\n  } = useUnmigratedOpenOrdersAccounts();\n  const marketsList = accounts && Array.from(new Set(accounts.map(openOrders => openOrders.market)));\n  const deps = marketsList && marketsList.map(m => m.toBase58());\n\n  const useUnmigratedDeprecatedMarketsInner = async () => {\n    if (!marketsList) {\n      return null;\n    }\n\n    const getMarket = async address => {\n      const marketInfo = USE_MARKETS.find(market => market.address.equals(address));\n\n      if (!marketInfo) {\n        console.log('Failed loading market');\n        notify({\n          message: 'Error loading market',\n          type: 'error'\n        });\n        return null;\n      }\n\n      try {\n        console.log('Loading market', marketInfo.name); // NOTE: Should this just be cached by (connection, marketInfo.address, marketInfo.programId)?\n\n        return await Market.load(connection, marketInfo.address, {}, marketInfo.programId);\n      } catch (e) {\n        console.log('Failed loading market', marketInfo.name, e);\n        notify({\n          message: 'Error loading market',\n          description: e.message,\n          type: 'error'\n        });\n        return null;\n      }\n    };\n\n    return (await Promise.all(marketsList.map(getMarket))).filter(x => x);\n  };\n\n  const [markets] = useAsyncData(useUnmigratedDeprecatedMarketsInner, tuple('useUnmigratedDeprecatedMarketsInner', connection, deps && deps.toString()), {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n\n  if (!markets) {\n    return null;\n  }\n\n  return markets.map(market => ({\n    market,\n    openOrdersList: accounts === null || accounts === void 0 ? void 0 : accounts.filter(openOrders => market && openOrders.market.equals(market.address))\n  }));\n}\nexport function useGetOpenOrdersForDeprecatedMarkets() {\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const {\n    customMarkets\n  } = useCustomMarkets();\n  const connection = useConnection();\n  const marketsAndOrders = useUnmigratedDeprecatedMarkets();\n  const marketsList = marketsAndOrders && marketsAndOrders.map(({\n    market\n  }) => market); // This isn't quite right: open order balances could change\n\n  const deps = marketsList && marketsList.filter(market => !!market).map(market => market.address.toBase58());\n\n  async function getOpenOrdersForDeprecatedMarkets() {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    if (!marketsList) {\n      return null;\n    }\n\n    console.log('refreshing getOpenOrdersForDeprecatedMarkets');\n\n    const getOrders = async market => {\n      if (!market) {\n        return null;\n      }\n\n      const {\n        marketName\n      } = getMarketDetails(market, customMarkets);\n\n      try {\n        console.log('Fetching open orders for', marketName); // Can do better than this, we have the open orders accounts already\n\n        return (await market.loadOrdersForOwner(connection, wallet.publicKey)).map(order => ({\n          marketName,\n          market,\n          ...order\n        }));\n      } catch (e) {\n        console.log('Failed loading open orders', market.address.toBase58(), e);\n        notify({\n          message: `Error loading open orders for deprecated ${marketName}`,\n          description: e.message,\n          type: 'error'\n        });\n        return null;\n      }\n    };\n\n    return (await Promise.all(marketsList.map(getOrders))).filter(x => !!x).flat();\n  }\n\n  const cacheKey = tuple('getOpenOrdersForDeprecatedMarkets', connected, connection, wallet, deps && deps.toString());\n  const [openOrders, loaded] = useAsyncData(getOpenOrdersForDeprecatedMarkets, cacheKey, {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n  console.log('openOrders', openOrders);\n  return {\n    openOrders,\n    loaded,\n    refreshOpenOrders: () => refreshCache(cacheKey)\n  };\n}\nexport function useBalancesForDeprecatedMarkets() {\n  const markets = useUnmigratedDeprecatedMarkets();\n  const [customMarkets] = useLocalStorageState('customMarkets', []);\n\n  if (!markets) {\n    return null;\n  }\n\n  const openOrderAccountBalances = [];\n  markets.forEach(({\n    market,\n    openOrdersList\n  }) => {\n    const {\n      baseCurrency,\n      quoteCurrency,\n      marketName\n    } = getMarketDetails(market, customMarkets);\n\n    if (!baseCurrency || !quoteCurrency || !market) {\n      return;\n    }\n\n    (openOrdersList || []).forEach(openOrders => {\n      const inOrdersBase = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.baseTokenTotal) && (openOrders === null || openOrders === void 0 ? void 0 : openOrders.baseTokenFree) && market.baseSplSizeToNumber(openOrders.baseTokenTotal.sub(openOrders.baseTokenFree));\n      const inOrdersQuote = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.quoteTokenTotal) && (openOrders === null || openOrders === void 0 ? void 0 : openOrders.quoteTokenFree) && market.baseSplSizeToNumber(openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree));\n      const unsettledBase = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.baseTokenFree) && market.baseSplSizeToNumber(openOrders.baseTokenFree);\n      const unsettledQuote = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.quoteTokenFree) && market.baseSplSizeToNumber(openOrders.quoteTokenFree);\n      openOrderAccountBalances.push({\n        marketName,\n        market,\n        coin: baseCurrency,\n        key: `${marketName}${baseCurrency}`,\n        orders: inOrdersBase,\n        unsettled: unsettledBase,\n        openOrders\n      });\n      openOrderAccountBalances.push({\n        marketName,\n        market,\n        coin: quoteCurrency,\n        key: `${marketName}${quoteCurrency}`,\n        orders: inOrdersQuote,\n        unsettled: unsettledQuote,\n        openOrders\n      });\n    });\n  });\n  return openOrderAccountBalances;\n}\nexport function getMarketInfos(customMarkets) {\n  const customMarketsInfo = customMarkets.filter(item => !USE_MARKETS.find(itemNew => itemNew.address.toString() === item.address && itemNew.deprecated === true)).map(m => ({ ...m,\n    address: new PublicKey(m.address),\n    programId: new PublicKey(m.programId),\n    deprecated: false\n  }));\n  return [...customMarketsInfo, ...USE_MARKETS];\n}\nexport function useMarketInfos() {\n  const {\n    customMarkets\n  } = useCustomMarkets();\n  return getMarketInfos(customMarkets);\n}\n/**\r\n * If selling, choose min tick size. If buying choose a price\r\n * s.t. given the state of the orderbook, the order will spend\r\n * `cost` cost currency.\r\n *\r\n * @param orderbook serum Orderbook object\r\n * @param cost quantity to spend. Base currency if selling,\r\n *  quote currency if buying.\r\n * @param tickSizeDecimals size of price increment of the market\r\n */\n\nexport function getMarketOrderPrice(orderbook, cost, tickSizeDecimals) {\n  if (orderbook.isBids) {\n    return orderbook.market.tickSize;\n  }\n\n  let spentCost = 0;\n  let price, sizeAtLevel, costAtLevel;\n  const asks = orderbook.getL2(1000);\n\n  for ([price, sizeAtLevel] of asks) {\n    costAtLevel = price * sizeAtLevel;\n\n    if (spentCost + costAtLevel > cost) {\n      break;\n    }\n\n    spentCost += costAtLevel;\n  }\n\n  const sendPrice = Math.min(price * 1.02, asks[0][0] * 1.05);\n  let formattedPrice;\n\n  if (tickSizeDecimals) {\n    formattedPrice = floorToDecimal(sendPrice, tickSizeDecimals);\n  } else {\n    formattedPrice = sendPrice;\n  }\n\n  return formattedPrice;\n}\nexport function getExpectedFillPrice(orderbook, cost, tickSizeDecimals) {\n  let spentCost = 0;\n  let avgPrice = 0;\n  let price, sizeAtLevel, costAtLevel;\n\n  for ([price, sizeAtLevel] of orderbook.getL2(1000)) {\n    costAtLevel = (orderbook.isBids ? 1 : price) * sizeAtLevel;\n\n    if (spentCost + costAtLevel > cost) {\n      avgPrice += (cost - spentCost) * price;\n      spentCost = cost;\n      break;\n    }\n\n    avgPrice += costAtLevel * price;\n    spentCost += costAtLevel;\n  }\n\n  const totalAvgPrice = avgPrice / Math.min(cost, spentCost);\n  let formattedPrice;\n\n  if (tickSizeDecimals) {\n    formattedPrice = floorToDecimal(totalAvgPrice, tickSizeDecimals);\n  } else {\n    formattedPrice = totalAvgPrice;\n  }\n\n  return formattedPrice;\n}\nexport function useCurrentlyAutoSettling() {\n  const [currentlyAutoSettling, setCurrentlyAutosettling] = useState(false);\n  return [currentlyAutoSettling, setCurrentlyAutosettling];\n}","map":{"version":3,"sources":["/home/dev/Code/dex-ui/src/utils/markets.tsx"],"names":["Market","OpenOrders","Orderbook","TOKEN_MINTS","TokenInstructions","React","useContext","useEffect","useState","getCache","setCache","divideBnToNumber","floorToDecimal","getTokenMultiplierFromDecimals","useLocalStorageState","getTokenAccountInfo","parseTokenAccountData","TOKENS","useMintInfos","refreshCache","useAsyncData","useAccountData","useAccountInfo","useConnection","BN","RaydiumApi","PublicKey","WRAPPED_SOL_MINT","notify","sleep","tuple","useWallet","_IGNORE_DEPRECATED","_MARKETS","name","deprecated","address","programId","USE_MARKETS","map","m","useMarketsList","filter","useAllMarkets","connection","customMarkets","useCustomMarkets","getAllMarkets","markets","Promise","all","getMarketInfos","marketInfo","market","load","marketName","e","message","description","type","length","refreshInterval","_VERY_SLOW_REFRESH_INTERVAL","useUnmigratedOpenOrdersAccounts","wallet","getUnmigratedOpenOrdersAccounts","publicKey","console","log","deprecatedOpenOrdersAccounts","deprecatedProgramIds","Array","from","Set","toBase58","publicKeyStr","openOrdersAccounts","findForOwner","concat","openOrders","baseTokenTotal","toNumber","quoteTokenTotal","some","equals","cacheKey","accounts","refresh","clearCache","MarketContext","createContext","_SLOW_REFRESH_INTERVAL","_SLOW_REFRESH_INTERVAL_NEW","_FAST_REFRESH_INTERVAL","DEFAULT_MARKET","find","getMarketDetails","marketInfos","otherMarket","indexItem","toString","Object","values","forEach","itemToken","item","mintAddress","push","symbol","baseCurrency","baseMintAddress","token","baseLabel","quoteCurrency","quoteMintAddress","quoteLabel","setCustomMarkets","MarketProvider","marketAddress","setMarketAddress","children","setMarket","setMarketName","localToken","setLocalToken","localMarket","setLocalMarket","fetchMarket","data","fetch","json","then","window","localStorage","setItem","JSON","stringify","marketData","marketDict","entries","itemMarket","getItem","parse","error","fetchToken","tokenData","mint","undefined","_decoded","ownAddress","catch","getTradePageUrl","saved","useSelectedTokenAccounts","selectedTokenAccounts","setSelectedTokenAccounts","useMarket","context","Error","useMarkPrice","markPrice","setMarkPrice","orderbook","useOrderbook","trades","useTrades","bb","bids","Number","ba","asks","last","price","sort","a","b","_useUnfilteredTrades","limit","getUnfilteredTrades","loadFills","useRaydiumTrades","getRaydiumTrades","getRecentTrades","useOrderbookAccounts","bidData","askData","bidOrderbook","decode","askOrderbook","depth","getL2","size","useOpenOrdersAccounts","fast","connected","getOpenOrdersAccounts","findOpenOrdersAccountsForOwner","getCachedMarket","getCachedOpenOrderAccounts","owner","useSelectedOpenOrdersAccount","useTokenAccounts","getTokenAccounts","getSelectedTokenAccountForMint","selectedPubKey","filtered","effectiveMint","pubkey","useSelectedQuoteCurrencyAccount","useSelectedBaseCurrencyAccount","useSelectedQuoteCurrencyBalances","quoteCurrencyAccount","accountInfo","loaded","lamports","quoteSplSizeToNumber","slice","useSelectedBaseCurrencyBalances","baseCurrencyAccount","baseSplSizeToNumber","useOpenOrders","openOrdersAccount","filterForOpenOrders","order","eventFlags","maker","trade","side","useLocallyStoredFeeDiscountKey","storedFeeDiscountKey","setStoredFeeDiscountKey","useFeeDiscountKeys","getFeeDiscountKeys","feeDiscountKey","findFeeDiscountKeys","useFills","fills","fill","useAllOpenOrdersAccounts","useMarketInfos","programIds","info","stringProgramId","getAllOpenOrdersAccounts","flat","useAllOpenOrdersBalances","loadedOpenOrdersAccounts","mintInfos","mintInfosConnected","allMarkets","marketsByAddress","fromEntries","openOrdersBalances","account","baseMint","quoteMint","baseMintInfo","baseFree","baseTokenFree","decimals","baseTotal","quoteMintInfo","quoteFree","quoteTokenFree","quoteTotal","free","total","useAllOpenOrders","setLoaded","setRefresh","setOpenOrders","lastRefresh","setLastRefresh","refreshOpenOrders","Date","getTime","prev","getAllOpenOrders","_openOrders","getOpenOrdersForMarket","Math","random","orders","loadOrdersForOwner","warn","useBalances","baseCurrencyBalances","quoteCurrencyBalances","baseExists","quoteExists","key","coin","sub","unsettled","useWalletBalancesForAllMarkets","tokenAccounts","balances","parsedAccount","amount","mintInfo","additionalAmount","balance","useUnmigratedDeprecatedMarkets","marketsList","deps","useUnmigratedDeprecatedMarketsInner","getMarket","x","openOrdersList","useGetOpenOrdersForDeprecatedMarkets","marketsAndOrders","getOpenOrdersForDeprecatedMarkets","getOrders","useBalancesForDeprecatedMarkets","openOrderAccountBalances","inOrdersBase","inOrdersQuote","unsettledBase","unsettledQuote","customMarketsInfo","itemNew","getMarketOrderPrice","cost","tickSizeDecimals","isBids","tickSize","spentCost","sizeAtLevel","costAtLevel","sendPrice","min","formattedPrice","getExpectedFillPrice","avgPrice","totalAvgPrice","useCurrentlyAutoSettling","currentlyAutoSettling","setCurrentlyAutosettling"],"mappings":"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","sourcesContent":["import {\r\n  Balances,\r\n  CustomMarketInfo,\r\n  DeprecatedOpenOrdersBalances,\r\n  FullMarketInfo,\r\n  MarketContextValues,\r\n  MarketInfo,\r\n  OrderWithMarketAndMarketName,\r\n  SelectedTokenAccounts,\r\n  TokenAccount,\r\n} from './types';\r\nimport {\r\n  // MARKETS,\r\n  Market,\r\n  OpenOrders,\r\n  Orderbook,\r\n  TOKEN_MINTS,\r\n  TokenInstructions,\r\n} from '@project-serum/serum';\r\nimport React, { useContext, useEffect, useState } from 'react';\r\nimport { getCache, setCache } from './fetch-loop';\r\nimport {\r\n  divideBnToNumber,\r\n  floorToDecimal,\r\n  getTokenMultiplierFromDecimals,\r\n  useLocalStorageState,\r\n} from './utils';\r\nimport {\r\n  getTokenAccountInfo,\r\n  parseTokenAccountData,\r\n  TOKENS,\r\n  useMintInfos,\r\n} from './tokens';\r\nimport { refreshCache, useAsyncData } from './fetch-loop';\r\nimport { useAccountData, useAccountInfo, useConnection } from './connection';\r\n\r\nimport BN from 'bn.js';\r\nimport RaydiumApi from './raydiumConnector';\r\nimport { Order } from '@project-serum/serum/lib/market';\r\nimport { PublicKey, Connection } from '@solana/web3.js';\r\nimport { WRAPPED_SOL_MINT } from '@project-serum/serum/lib/token-instructions';\r\nimport { notify } from './notifications';\r\nimport { sleep } from './utils';\r\nimport tuple from 'immutable-tuple';\r\nimport { useWallet } from './wallet';\r\n\r\n// Used in debugging, should be false in production\r\nconst _IGNORE_DEPRECATED = false;\r\n\r\nconst _MARKETS = [\r\n  {\r\n    name: 'RAY/soUSDT',\r\n    deprecated: true,\r\n    address: new PublicKey('C4z32zw9WKaGPhNuU54ohzrV4CE1Uau3cFx6T8RLjxYC'),\r\n    programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'),\r\n  },\r\n  {\r\n    name: 'RAY/USDC',\r\n    deprecated: false,\r\n    address: new PublicKey('2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep'),\r\n    programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'),\r\n  },\r\n  {\r\n    name: 'RAY/USDT',\r\n    deprecated: false,\r\n    address: new PublicKey('teE55QrL4a4QSfydR9dnHF97jgCfptpuigbb53Lo95g'),\r\n    programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'),\r\n  },\r\n  {\r\n    name: 'RAY/SRM',\r\n    deprecated: false,\r\n    address: new PublicKey('Cm4MmknScg7qbKqytb1mM92xgDxv3TNXos4tKbBqTDy7'),\r\n    programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'),\r\n  },\r\n  {\r\n    name: 'RAY/SOL',\r\n    deprecated: false,\r\n    address: new PublicKey('C6tp2RVZnxBPFbnAsfTjis8BN9tycESAT4SgDQgbbrsA'),\r\n    programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'),\r\n  },\r\n  {\r\n    name: 'RAY/soETH',\r\n    deprecated: false,\r\n    address: new PublicKey('6jx6aoNFbmorwyncVP5V5ESKfuFc9oUYebob1iF6tgN4'),\r\n    programId: new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin'),\r\n  },\r\n  // ...MARKETS,\r\n];\r\n\r\n// MARKETS.forEach(item => {\r\n//   if (item.address.toBase58() === '5GAPymgnnWieGcRrcghZdA3aanefqa4cZx1ZSE8UTyMV') return\r\n//   if (_MARKETS.find(oldMarket => oldMarket.address.toBase58() === item.address.toBase58())) return\r\n\r\n//   if (item.address.toBase58() === '7MpMwArporUHEGW7quUpkPZp5L5cHPs9eKUfKCdaPHq2') {\r\n//     _MARKETS.push( {\r\n//       address: item.address,\r\n//       name: 'xCOPE/USDC',\r\n//       programId: item.programId,\r\n//       deprecated: item.deprecated,\r\n//     })\r\n//     return\r\n//   }\r\n\r\n//   _MARKETS.push(item)\r\n// })\r\n\r\nexport const USE_MARKETS: MarketInfo[] = _IGNORE_DEPRECATED\r\n  ? _MARKETS.map((m) => ({ ...m, deprecated: false }))\r\n  : _MARKETS;\r\n\r\nexport function useMarketsList() {\r\n  return USE_MARKETS.filter(({ deprecated }) => !deprecated);\r\n}\r\n\r\nexport function useAllMarkets() {\r\n  const connection = useConnection();\r\n  const { customMarkets } = useCustomMarkets();\r\n\r\n  const getAllMarkets = async () => {\r\n    const markets: Array<{\r\n      market: Market;\r\n      marketName: string;\r\n      programId: PublicKey;\r\n    } | null> = await Promise.all(\r\n      getMarketInfos(customMarkets).map(async (marketInfo) => {\r\n        try {\r\n          const market = await Market.load(\r\n            connection,\r\n            marketInfo.address,\r\n            {},\r\n            marketInfo.programId,\r\n          );\r\n          return {\r\n            market,\r\n            marketName: marketInfo.name,\r\n            programId: marketInfo.programId,\r\n          };\r\n        } catch (e) {\r\n          notify({\r\n            message: 'Error loading all market',\r\n            description: e.message,\r\n            type: 'error',\r\n          });\r\n          return null;\r\n        }\r\n      }),\r\n    );\r\n    return markets.filter(\r\n      (m): m is { market: Market; marketName: string; programId: PublicKey } =>\r\n        !!m,\r\n    );\r\n  };\r\n  return useAsyncData(\r\n    getAllMarkets,\r\n    tuple('getAllMarkets', customMarkets.length, connection),\r\n    { refreshInterval: _VERY_SLOW_REFRESH_INTERVAL },\r\n  );\r\n}\r\n\r\nexport function useUnmigratedOpenOrdersAccounts() {\r\n  const connection = useConnection();\r\n  const { wallet } = useWallet();\r\n\r\n  async function getUnmigratedOpenOrdersAccounts(): Promise<OpenOrders[]> {\r\n    if (!wallet || !connection || !wallet.publicKey) {\r\n      return [];\r\n    }\r\n    console.log('refreshing useUnmigratedOpenOrdersAccounts');\r\n    let deprecatedOpenOrdersAccounts: OpenOrders[] = [];\r\n    const deprecatedProgramIds = Array.from(\r\n      new Set(\r\n        USE_MARKETS.filter(({ deprecated }) => deprecated).map(\r\n          ({ programId }) => programId.toBase58(),\r\n        ),\r\n      ),\r\n    ).map((publicKeyStr) => new PublicKey(publicKeyStr));\r\n    let programId: PublicKey;\r\n    for (programId of deprecatedProgramIds) {\r\n      try {\r\n        const openOrdersAccounts = await OpenOrders.findForOwner(\r\n          connection,\r\n          wallet.publicKey,\r\n          programId,\r\n        );\r\n        deprecatedOpenOrdersAccounts = deprecatedOpenOrdersAccounts.concat(\r\n          openOrdersAccounts\r\n            .filter(\r\n              (openOrders) =>\r\n                openOrders.baseTokenTotal.toNumber() ||\r\n                openOrders.quoteTokenTotal.toNumber(),\r\n            )\r\n            .filter((openOrders) =>\r\n              USE_MARKETS.some(\r\n                (market) =>\r\n                  market.deprecated && market.address.equals(openOrders.market),\r\n              ),\r\n            ),\r\n        );\r\n      } catch (e) {\r\n        console.log(\r\n          'Error loading deprecated markets',\r\n          programId?.toBase58(),\r\n          e.message,\r\n        );\r\n      }\r\n    }\r\n    // Maybe sort\r\n    return deprecatedOpenOrdersAccounts;\r\n  }\r\n\r\n  const cacheKey = tuple(\r\n    'getUnmigratedOpenOrdersAccounts',\r\n    connection,\r\n    wallet?.publicKey?.toBase58(),\r\n  );\r\n  const [accounts] = useAsyncData(getUnmigratedOpenOrdersAccounts, cacheKey, {\r\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL,\r\n  });\r\n\r\n  return {\r\n    accounts,\r\n    refresh: (clearCache: boolean) => refreshCache(cacheKey, clearCache),\r\n  };\r\n}\r\n\r\nconst MarketContext: React.Context<null | MarketContextValues> =\r\n  React.createContext<null | MarketContextValues>(null);\r\n\r\nconst _VERY_SLOW_REFRESH_INTERVAL = 5000 * 1000;\r\n\r\n// For things that don't really change\r\nconst _SLOW_REFRESH_INTERVAL = 5 * 1000;\r\nconst _SLOW_REFRESH_INTERVAL_NEW = 60 * 1000;\r\n\r\n// For things that change frequently\r\nconst _FAST_REFRESH_INTERVAL = 1000;\r\n\r\nexport const DEFAULT_MARKET = USE_MARKETS.find(\r\n  ({ name, deprecated }) => name === 'RAY/USDC' && !deprecated,\r\n);\r\n\r\nexport function getMarketDetails(\r\n  market: Market | undefined | null,\r\n  customMarkets: CustomMarketInfo[],\r\n): FullMarketInfo {\r\n  if (!market) {\r\n    return {};\r\n  }\r\n  const marketInfos = getMarketInfos(customMarkets);\r\n  const marketInfo = marketInfos.find((otherMarket) =>\r\n    otherMarket.address.equals(market.address),\r\n  );\r\n\r\n  // add new token here\r\n  // TOKEN_MINTS.push({\r\n  //   address: new PublicKey('4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R'),\r\n  //   name: 'RAY',\r\n  // });\r\n  for (let indexItem = 0; indexItem < TOKEN_MINTS.length; indexItem += 1) {\r\n    if (\r\n      TOKEN_MINTS[indexItem].address.toString() ===\r\n      '3K6rftdAaQYMPunrtNRHgnK2UAtjm2JwyT2oCiTDouYE'\r\n    ) {\r\n      TOKEN_MINTS[indexItem].name = 'xCOPE';\r\n    }\r\n  }\r\n\r\n  Object.values(TOKENS).forEach((itemToken) => {\r\n    if (\r\n      !TOKEN_MINTS.find(\r\n        (item) => item.address.toString === itemToken.mintAddress,\r\n      )\r\n    ) {\r\n      TOKEN_MINTS.push({\r\n        address: new PublicKey(itemToken.mintAddress),\r\n        name: itemToken.symbol,\r\n      });\r\n    }\r\n  });\r\n\r\n  const baseCurrency =\r\n    (market?.baseMintAddress &&\r\n      TOKEN_MINTS.find((token) => token.address.equals(market.baseMintAddress))\r\n        ?.name) ||\r\n    (marketInfo?.baseLabel && `${marketInfo?.baseLabel}*`) ||\r\n    'UNKNOWN';\r\n  const quoteCurrency =\r\n    (market?.quoteMintAddress &&\r\n      TOKEN_MINTS.find((token) => token.address.equals(market.quoteMintAddress))\r\n        ?.name) ||\r\n    (marketInfo?.quoteLabel && `${marketInfo?.quoteLabel}*`) ||\r\n    'UNKNOWN';\r\n  return {\r\n    ...marketInfo,\r\n    marketName: marketInfo?.name,\r\n    baseCurrency,\r\n    quoteCurrency,\r\n    marketInfo,\r\n  };\r\n}\r\n\r\nexport function useCustomMarkets() {\r\n  const [customMarkets, setCustomMarkets] = useLocalStorageState<\r\n    CustomMarketInfo[]\r\n  >('customMarkets', []);\r\n  return { customMarkets, setCustomMarkets };\r\n}\r\n\r\nexport function MarketProvider({ marketAddress, setMarketAddress, children }) {\r\n  const { customMarkets, setCustomMarkets } = useCustomMarkets();\r\n\r\n  const address = marketAddress && new PublicKey(marketAddress);\r\n  const connection = useConnection();\r\n  const marketInfos = getMarketInfos(customMarkets);\r\n  const marketInfo =\r\n    address && marketInfos.find((market) => market.address.equals(address));\r\n\r\n  const [market, setMarket] = useState<Market | null>();\r\n\r\n  const [marketName, setMarketName] = useState('RAY/USDT');\r\n\r\n  const [localToken, setLocalToken] = useState(false)\r\n  const [localMarket, setLocalMarket] = useState(false)\r\n\r\n  useEffect(() => {\r\n    const fetchMarket = async () => {\r\n      const data = await fetch('https://api.raydium.io/v1/dex/market');\r\n      const json = await data.json();\r\n      return json;\r\n    };\r\n\r\n    fetchMarket().then((json) => {\r\n      window.localStorage.setItem('apiMarket', JSON.stringify(json));\r\n      const marketData: { [programId: string]: { [market: string]: string } } =\r\n        (json ?? {}).data ?? {};\r\n      for (const [programId, marketDict] of Object.entries(marketData)) {\r\n        for (const [itemMarket, marketName] of Object.entries(marketDict)) {\r\n          if (\r\n            !_MARKETS.find((item) => item.address.toString() === itemMarket)\r\n          ) {\r\n            _MARKETS.push({\r\n              name: marketName,\r\n              deprecated: false,\r\n              address: new PublicKey(itemMarket),\r\n              programId: new PublicKey(programId),\r\n            });\r\n          }\r\n        }\r\n      }\r\n      console.log('load market over')\r\n      setLocalMarket(true)\r\n    });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const localMarket = window.localStorage.getItem('apiMarket');\r\n    try {\r\n      if (localMarket === null) {\r\n        console.log('no local market');\r\n        return\r\n      }\r\n      const marketData: { [programId: string]: { [market: string]: string } } =\r\n        (JSON.parse(localMarket) ?? {}).data ?? {};\r\n      for (const [programId, marketDict] of Object.entries(marketData)) {\r\n        for (const [itemMarket, marketName] of Object.entries(marketDict)) {\r\n          if (\r\n            !_MARKETS.find((item) => item.address.toString() === itemMarket)\r\n          ) {\r\n            _MARKETS.push({\r\n              name: marketName,\r\n              deprecated: false,\r\n              address: new PublicKey(itemMarket),\r\n              programId: new PublicKey(programId),\r\n            });\r\n          }\r\n        }\r\n      }\r\n      console.log('local market over')\r\n      setLocalMarket(true)\r\n    } catch (e) {\r\n      console.error('local market error', e);\r\n    }\r\n  }, []);\r\n\r\n\r\n\r\n  useEffect(() => {\r\n    const fetchToken = async () => {\r\n      const data = await fetch('https://api.raydium.io/v1/dex/token');\r\n      const json = await data.json();\r\n      return json;\r\n    };\r\n\r\n    fetchToken().then((json) => {\r\n      window.localStorage.setItem('apiToken', JSON.stringify(json));\r\n      const tokenData: { [programId: string]: { [market: string]: string } } =\r\n        (json ?? {}).data ?? {};\r\n      for (const [mint, symbol] of Object.entries(tokenData)) {\r\n        if (\r\n          TOKENS[mint] === undefined || !Object.values(TOKENS).find((item) => item.mintAddress === mint)\r\n        ) {\r\n          TOKENS[mint] = {\r\n            symbol,\r\n            mintAddress: mint,\r\n          };\r\n        }\r\n      }\r\n      setLocalToken(true)\r\n      console.log('load token over')\r\n    });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const localToken = window.localStorage.getItem('apiToken');\r\n    try {\r\n      if (localToken === null) {\r\n        console.log('no local token');\r\n        return\r\n      }\r\n      const json = JSON.parse(localToken)\r\n      const tokenData: { [programId: string]: { [market: string]: string } } =\r\n        (json ?? {}).data ?? {};\r\n      for (const [mint, symbol] of Object.entries(tokenData)) {\r\n        if (\r\n          TOKENS[mint] === undefined || !Object.values(TOKENS).find((item) => item.mintAddress === mint)\r\n        ) {\r\n          TOKENS[mint] = {\r\n            symbol,\r\n            mintAddress: mint,\r\n          };\r\n        }\r\n      }\r\n      setLocalToken(true)\r\n      console.log('local token over')\r\n    } catch (e) {\r\n      console.error('local token error', e);\r\n    }\r\n  }, []);\r\n\r\n  // Replace existing market with a non-deprecated one on first load\r\n  useEffect(() => {\r\n    if (marketInfo) {\r\n      if (marketInfo.deprecated) {\r\n        console.log('Switching markets from deprecated', marketInfo);\r\n        if (DEFAULT_MARKET) {\r\n          // setMarketAddress(DEFAULT_MARKET.address.toBase58());\r\n          setMarketAddress('2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep');\r\n        }\r\n      }\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (\r\n      market &&\r\n      marketInfo &&\r\n      // @ts-ignore\r\n      market._decoded.ownAddress?.equals(marketInfo?.address)\r\n    ) {\r\n      return;\r\n    }\r\n    if (!localMarket || !localToken) return;\r\n    setMarket(null);\r\n    if (!marketInfo || !marketInfo.address) {\r\n      notify({\r\n        message: 'Error loading market',\r\n        description: 'Please select a market from the dropdown',\r\n        type: 'error',\r\n      });\r\n      return;\r\n    } else {\r\n      setMarketName(marketInfo.name);\r\n    }\r\n    Market.load(connection, marketInfo.address, {}, marketInfo.programId)\r\n      .then(setMarket)\r\n      .catch((e) =>\r\n        notify({\r\n          message: 'Error loading market',\r\n          description: e.message,\r\n          type: 'error',\r\n        }),\r\n      );\r\n    // eslint-disable-next-line\r\n  }, [connection, marketInfo, USE_MARKETS, localMarket, localToken]);\r\n\r\n  return (\r\n    <MarketContext.Provider\r\n      value={{\r\n        market,\r\n        ...getMarketDetails(market, customMarkets),\r\n        setMarketAddress,\r\n        customMarkets,\r\n        setCustomMarkets,\r\n        marketName,\r\n      }}\r\n    >\r\n      {children}\r\n    </MarketContext.Provider>\r\n  );\r\n}\r\n\r\nexport function getTradePageUrl(marketAddress?: string) {\r\n  if (!marketAddress) {\r\n    const saved = localStorage.getItem('marketAddress');\r\n    if (saved) {\r\n      marketAddress = JSON.parse(saved);\r\n    }\r\n    marketAddress =\r\n      marketAddress ||\r\n      DEFAULT_MARKET?.address.toBase58() ||\r\n      '2xiv8A5xrJ7RnGdxXB42uFEkYHJjszEhaJyKKt4WaLep';\r\n  }\r\n  return `/market/${marketAddress}`;\r\n}\r\n\r\nexport function useSelectedTokenAccounts(): [\r\n  SelectedTokenAccounts,\r\n  (newSelectedTokenAccounts: SelectedTokenAccounts) => void,\r\n] {\r\n  const [selectedTokenAccounts, setSelectedTokenAccounts] =\r\n    useLocalStorageState<SelectedTokenAccounts>('selectedTokenAccounts', {});\r\n  return [selectedTokenAccounts, setSelectedTokenAccounts];\r\n}\r\n\r\nexport function useMarket() {\r\n  const context = useContext(MarketContext);\r\n  if (!context) {\r\n    throw new Error('Missing market context');\r\n  }\r\n  return context;\r\n}\r\n\r\nexport function useMarkPrice() {\r\n  const [markPrice, setMarkPrice] = useState<null | number>(null);\r\n\r\n  const [orderbook] = useOrderbook();\r\n  const trades = useTrades();\r\n\r\n  useEffect(() => {\r\n    let bb = orderbook?.bids?.length > 0 && Number(orderbook.bids[0][0]);\r\n    let ba = orderbook?.asks?.length > 0 && Number(orderbook.asks[0][0]);\r\n    let last = trades && trades.length > 0 && trades[0].price;\r\n\r\n    let markPrice =\r\n      bb && ba\r\n        ? last\r\n          ? [bb, ba, last].sort((a, b) => a - b)[1]\r\n          : (bb + ba) / 2\r\n        : null;\r\n\r\n    setMarkPrice(markPrice);\r\n  }, [orderbook, trades]);\r\n\r\n  return markPrice;\r\n}\r\n\r\nexport function _useUnfilteredTrades(limit = 10000) {\r\n  const { market } = useMarket();\r\n  const connection = useConnection();\r\n  async function getUnfilteredTrades(): Promise<any[] | null> {\r\n    if (!market || !connection) {\r\n      return null;\r\n    }\r\n    return await market.loadFills(connection, limit);\r\n  }\r\n  const [trades] = useAsyncData(\r\n    getUnfilteredTrades,\r\n    tuple('getUnfilteredTrades', market, connection),\r\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\r\n  );\r\n  return trades;\r\n  // NOTE: For now, websocket is too expensive since the event queue is large\r\n  // and updates very frequently\r\n\r\n  // let data = useAccountData(market && market._decoded.eventQueue);\r\n  // if (!data) {\r\n  //   return null;\r\n  // }\r\n  // const events = decodeEventQueue(data, limit);\r\n  // return events\r\n  //   .filter((event) => event.eventFlags.fill && event.nativeQuantityPaid.gtn(0))\r\n  //   .map(market.parseFillEvent.bind(market));\r\n}\r\n\r\nexport function useRaydiumTrades() {\r\n  const { market } = useMarket();\r\n  const marketAddress = market?.address.toBase58();\r\n\r\n  async function getRaydiumTrades() {\r\n    if (!marketAddress) {\r\n      return null;\r\n    }\r\n    return await RaydiumApi.getRecentTrades(marketAddress);\r\n  }\r\n\r\n  return useAsyncData(\r\n    getRaydiumTrades,\r\n    tuple('getRaydiumTrades', marketAddress),\r\n    { refreshInterval: _SLOW_REFRESH_INTERVAL_NEW },\r\n    false,\r\n  );\r\n}\r\n\r\nexport function useOrderbookAccounts() {\r\n  const { market } = useMarket();\r\n  // @ts-ignore\r\n  let bidData = useAccountData(market && market._decoded.bids);\r\n  // @ts-ignore\r\n  let askData = useAccountData(market && market._decoded.asks);\r\n  return {\r\n    bidOrderbook: market && bidData ? Orderbook.decode(market, bidData) : null,\r\n    askOrderbook: market && askData ? Orderbook.decode(market, askData) : null,\r\n  };\r\n}\r\n\r\nexport function useOrderbook(\r\n  depth = 20,\r\n): [{ bids: number[][]; asks: number[][] }, boolean] {\r\n  const { bidOrderbook, askOrderbook } = useOrderbookAccounts();\r\n  const { market } = useMarket();\r\n  const bids =\r\n    !bidOrderbook || !market\r\n      ? []\r\n      : bidOrderbook.getL2(depth).map(([price, size]) => [price, size]);\r\n  const asks =\r\n    !askOrderbook || !market\r\n      ? []\r\n      : askOrderbook.getL2(depth).map(([price, size]) => [price, size]);\r\n  return [{ bids, asks }, !!bids || !!asks];\r\n}\r\n\r\n// Want the balances table to be fast-updating, dont want open orders to flicker\r\n// TODO: Update to use websocket\r\nexport function useOpenOrdersAccounts(fast = false) {\r\n  const { market } = useMarket();\r\n  const { connected, wallet } = useWallet();\r\n  const connection = useConnection();\r\n  async function getOpenOrdersAccounts() {\r\n    if (!connected || !wallet) {\r\n      return null;\r\n    }\r\n    if (!market) {\r\n      return null;\r\n    }\r\n    return await market.findOpenOrdersAccountsForOwner(\r\n      connection,\r\n      wallet.publicKey,\r\n    );\r\n  }\r\n  return useAsyncData<OpenOrders[] | null>(\r\n    getOpenOrdersAccounts,\r\n    tuple('getOpenOrdersAccounts', wallet, market, connected),\r\n    { refreshInterval: fast ? _FAST_REFRESH_INTERVAL : _SLOW_REFRESH_INTERVAL },\r\n  );\r\n}\r\n\r\n// todo: refresh cache after some time?\r\nexport async function getCachedMarket(\r\n  connection: Connection,\r\n  address: PublicKey,\r\n  programId: PublicKey,\r\n) {\r\n  let market;\r\n  const cacheKey = tuple(\r\n    'getCachedMarket',\r\n    'market',\r\n    address.toString(),\r\n    connection,\r\n  );\r\n  if (!getCache(cacheKey)) {\r\n    market = await Market.load(connection, address, {}, programId);\r\n    setCache(cacheKey, market);\r\n  } else {\r\n    market = getCache(cacheKey);\r\n  }\r\n  return market;\r\n}\r\n\r\nexport async function getCachedOpenOrderAccounts(\r\n  connection: Connection,\r\n  market: Market,\r\n  owner: PublicKey,\r\n) {\r\n  let accounts;\r\n  const cacheKey = tuple(\r\n    'getCachedOpenOrderAccounts',\r\n    market.address.toString(),\r\n    owner.toString(),\r\n    connection,\r\n  );\r\n  if (!getCache(cacheKey)) {\r\n    accounts = await market.findOpenOrdersAccountsForOwner(connection, owner);\r\n    setCache(cacheKey, accounts);\r\n  } else {\r\n    accounts = getCache(cacheKey);\r\n  }\r\n  return accounts;\r\n}\r\n\r\nexport function useSelectedOpenOrdersAccount(fast = false) {\r\n  const [accounts] = useOpenOrdersAccounts(fast);\r\n  if (!accounts) {\r\n    return null;\r\n  }\r\n  return accounts[0];\r\n}\r\n\r\nexport function useTokenAccounts(): [\r\n  TokenAccount[] | null | undefined,\r\n  boolean,\r\n] {\r\n  const { connected, wallet } = useWallet();\r\n  const connection = useConnection();\r\n  async function getTokenAccounts() {\r\n    if (!connected || !wallet) {\r\n      return null;\r\n    }\r\n    return await getTokenAccountInfo(connection, wallet.publicKey);\r\n  }\r\n  return useAsyncData(\r\n    getTokenAccounts,\r\n    tuple('getTokenAccounts', wallet, connected),\r\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\r\n  );\r\n}\r\n\r\nexport function getSelectedTokenAccountForMint(\r\n  accounts: TokenAccount[] | undefined | null,\r\n  mint: PublicKey | undefined,\r\n  selectedPubKey?: string | PublicKey | null,\r\n) {\r\n  if (!accounts || !mint) {\r\n    return null;\r\n  }\r\n  const filtered = accounts.filter(\r\n    ({ effectiveMint, pubkey }) =>\r\n      mint.equals(effectiveMint) &&\r\n      (!selectedPubKey ||\r\n        (typeof selectedPubKey === 'string'\r\n          ? selectedPubKey\r\n          : selectedPubKey.toBase58()) === pubkey.toBase58()),\r\n  );\r\n  return filtered && filtered[0];\r\n}\r\n\r\nexport function useSelectedQuoteCurrencyAccount() {\r\n  const [accounts] = useTokenAccounts();\r\n  const { market } = useMarket();\r\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\r\n  const mintAddress = market?.quoteMintAddress;\r\n  return getSelectedTokenAccountForMint(\r\n    accounts,\r\n    mintAddress,\r\n    mintAddress && selectedTokenAccounts[mintAddress.toBase58()],\r\n  );\r\n}\r\n\r\nexport function useSelectedBaseCurrencyAccount() {\r\n  const [accounts] = useTokenAccounts();\r\n  const { market } = useMarket();\r\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\r\n  const mintAddress = market?.baseMintAddress;\r\n  return getSelectedTokenAccountForMint(\r\n    accounts,\r\n    mintAddress,\r\n    mintAddress && selectedTokenAccounts[mintAddress.toBase58()],\r\n  );\r\n}\r\n\r\n// TODO: Update to use websocket\r\nexport function useSelectedQuoteCurrencyBalances() {\r\n  const quoteCurrencyAccount = useSelectedQuoteCurrencyAccount();\r\n  const { market } = useMarket();\r\n  const [accountInfo, loaded] = useAccountInfo(quoteCurrencyAccount?.pubkey);\r\n  if (!market || !quoteCurrencyAccount || !loaded || !accountInfo) {\r\n    return null;\r\n  }\r\n  if (market.quoteMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\r\n    return accountInfo?.lamports / 1e9 ?? 0;\r\n  }\r\n  return market.quoteSplSizeToNumber(\r\n    new BN(accountInfo.data.slice(64, 72), 10, 'le'),\r\n  );\r\n}\r\n\r\n// TODO: Update to use websocket\r\nexport function useSelectedBaseCurrencyBalances() {\r\n  const baseCurrencyAccount = useSelectedBaseCurrencyAccount();\r\n  const { market } = useMarket();\r\n  const [accountInfo, loaded] = useAccountInfo(baseCurrencyAccount?.pubkey);\r\n  if (!market || !baseCurrencyAccount || !loaded || !accountInfo) {\r\n    return null;\r\n  }\r\n  if (market.baseMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\r\n    return accountInfo?.lamports / 1e9 ?? 0;\r\n  }\r\n  return market.baseSplSizeToNumber(\r\n    new BN(accountInfo.data.slice(64, 72), 10, 'le'),\r\n  );\r\n}\r\n\r\nexport function useOpenOrders() {\r\n  const { market, marketName } = useMarket();\r\n  const openOrdersAccount = useSelectedOpenOrdersAccount();\r\n  const { bidOrderbook, askOrderbook } = useOrderbookAccounts();\r\n  if (!market || !openOrdersAccount || !bidOrderbook || !askOrderbook) {\r\n    return null;\r\n  }\r\n  return market\r\n    .filterForOpenOrders(bidOrderbook, askOrderbook, [openOrdersAccount])\r\n    .map((order) => ({ ...order, marketName, market }));\r\n}\r\n\r\nexport function useTrades(limit = 100) {\r\n  const trades = _useUnfilteredTrades(limit);\r\n  if (!trades) {\r\n    return null;\r\n  }\r\n  // Until partial fills are each given their own fill, use maker fills\r\n  return trades\r\n    .filter(({ eventFlags }) => eventFlags.maker)\r\n    .map((trade) => ({\r\n      ...trade,\r\n      side: trade.side === 'buy' ? 'sell' : 'buy',\r\n    }));\r\n}\r\n\r\nexport function useLocallyStoredFeeDiscountKey(): {\r\n  storedFeeDiscountKey: PublicKey | undefined;\r\n  setStoredFeeDiscountKey: (key: string) => void;\r\n} {\r\n  const [storedFeeDiscountKey, setStoredFeeDiscountKey] =\r\n    useLocalStorageState<string>(`feeDiscountKey`, undefined);\r\n  return {\r\n    storedFeeDiscountKey: storedFeeDiscountKey\r\n      ? new PublicKey(storedFeeDiscountKey)\r\n      : undefined,\r\n    setStoredFeeDiscountKey,\r\n  };\r\n}\r\n\r\nexport function useFeeDiscountKeys(): [\r\n  (\r\n    | {\r\n        pubkey: PublicKey;\r\n        feeTier: number;\r\n        balance: number;\r\n        mint: PublicKey;\r\n      }[]\r\n    | null\r\n    | undefined\r\n  ),\r\n  boolean,\r\n] {\r\n  const { market } = useMarket();\r\n  const { connected, wallet } = useWallet();\r\n  const connection = useConnection();\r\n  const { setStoredFeeDiscountKey } = useLocallyStoredFeeDiscountKey();\r\n  let getFeeDiscountKeys = async () => {\r\n    if (!connected || !wallet) {\r\n      return null;\r\n    }\r\n    if (!market) {\r\n      return null;\r\n    }\r\n    const feeDiscountKey = await market.findFeeDiscountKeys(\r\n      connection,\r\n      wallet.publicKey,\r\n    );\r\n    if (feeDiscountKey) {\r\n      setStoredFeeDiscountKey(feeDiscountKey[0].pubkey.toBase58());\r\n    }\r\n    return feeDiscountKey;\r\n  };\r\n  return useAsyncData(\r\n    getFeeDiscountKeys,\r\n    tuple('getFeeDiscountKeys', wallet, market, connected),\r\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\r\n  );\r\n}\r\n\r\nexport function useFills(limit = 100) {\r\n  const { marketName } = useMarket();\r\n  const fills = _useUnfilteredTrades(limit);\r\n  const [openOrdersAccounts] = useOpenOrdersAccounts();\r\n  if (!openOrdersAccounts || openOrdersAccounts.length === 0) {\r\n    return null;\r\n  }\r\n  if (!fills) {\r\n    return null;\r\n  }\r\n  return fills\r\n    .filter((fill) =>\r\n      openOrdersAccounts.some((openOrdersAccount) =>\r\n        fill.openOrders.equals(openOrdersAccount.publicKey),\r\n      ),\r\n    )\r\n    .map((fill) => ({ ...fill, marketName }));\r\n}\r\n\r\nexport function useAllOpenOrdersAccounts() {\r\n  const { wallet, connected } = useWallet();\r\n  const connection = useConnection();\r\n  const marketInfos = useMarketInfos();\r\n  const programIds = [\r\n    ...new Set(marketInfos.map((info) => info.programId.toBase58())),\r\n  ].map((stringProgramId) => new PublicKey(stringProgramId));\r\n\r\n  const getAllOpenOrdersAccounts = async () => {\r\n    if (!connected || !wallet) {\r\n      return [];\r\n    }\r\n    return (\r\n      await Promise.all(\r\n        programIds.map((programId) =>\r\n          OpenOrders.findForOwner(connection, wallet.publicKey, programId),\r\n        ),\r\n      )\r\n    ).flat();\r\n  };\r\n  return useAsyncData(\r\n    getAllOpenOrdersAccounts,\r\n    tuple(\r\n      'getAllOpenOrdersAccounts',\r\n      connection,\r\n      connected,\r\n      wallet?.publicKey?.toBase58(),\r\n      marketInfos.length,\r\n      (programIds || []).length,\r\n    ),\r\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\r\n  );\r\n}\r\n\r\nexport function useAllOpenOrdersBalances() {\r\n  const [openOrdersAccounts, loadedOpenOrdersAccounts] =\r\n    useAllOpenOrdersAccounts();\r\n  const [mintInfos, mintInfosConnected] = useMintInfos();\r\n  const [allMarkets] = useAllMarkets();\r\n  if (!loadedOpenOrdersAccounts || !mintInfosConnected) {\r\n    return {};\r\n  }\r\n\r\n  const marketsByAddress = Object.fromEntries(\r\n    (allMarkets || []).map((m) => [m.market.address.toBase58(), m]),\r\n  );\r\n  const openOrdersBalances: {\r\n    [mint: string]: { market: PublicKey; free: number; total: number }[];\r\n  } = {};\r\n  for (let account of openOrdersAccounts || []) {\r\n    const marketInfo = marketsByAddress[account.market.toBase58()];\r\n    const baseMint = marketInfo?.market.baseMintAddress.toBase58();\r\n    const quoteMint = marketInfo?.market.quoteMintAddress.toBase58();\r\n    if (!(baseMint in openOrdersBalances)) {\r\n      openOrdersBalances[baseMint] = [];\r\n    }\r\n    if (!(quoteMint in openOrdersBalances)) {\r\n      openOrdersBalances[quoteMint] = [];\r\n    }\r\n\r\n    const baseMintInfo = mintInfos && mintInfos[baseMint];\r\n    const baseFree = divideBnToNumber(\r\n      new BN(account.baseTokenFree),\r\n      getTokenMultiplierFromDecimals(baseMintInfo?.decimals || 0),\r\n    );\r\n    const baseTotal = divideBnToNumber(\r\n      new BN(account.baseTokenTotal),\r\n      getTokenMultiplierFromDecimals(baseMintInfo?.decimals || 0),\r\n    );\r\n    const quoteMintInfo = mintInfos && mintInfos[quoteMint];\r\n    const quoteFree = divideBnToNumber(\r\n      new BN(account.quoteTokenFree),\r\n      getTokenMultiplierFromDecimals(quoteMintInfo?.decimals || 0),\r\n    );\r\n    const quoteTotal = divideBnToNumber(\r\n      new BN(account.quoteTokenTotal),\r\n      getTokenMultiplierFromDecimals(quoteMintInfo?.decimals || 0),\r\n    );\r\n\r\n    openOrdersBalances[baseMint].push({\r\n      market: account.market,\r\n      free: baseFree,\r\n      total: baseTotal,\r\n    });\r\n    openOrdersBalances[quoteMint].push({\r\n      market: account.market,\r\n      free: quoteFree,\r\n      total: quoteTotal,\r\n    });\r\n  }\r\n  return openOrdersBalances;\r\n}\r\n\r\nexport const useAllOpenOrders = (): {\r\n  openOrders: { orders: Order[]; marketAddress: string }[] | null | undefined;\r\n  loaded: boolean;\r\n  refreshOpenOrders: () => void;\r\n} => {\r\n  const connection = useConnection();\r\n  const { connected, wallet } = useWallet();\r\n  const [loaded, setLoaded] = useState(false);\r\n  const [refresh, setRefresh] = useState(0);\r\n  const [openOrders, setOpenOrders] = useState<\r\n    { orders: Order[]; marketAddress: string }[] | null | undefined\r\n  >(null);\r\n  const [lastRefresh, setLastRefresh] = useState(0);\r\n\r\n  const refreshOpenOrders = () => {\r\n    if (new Date().getTime() - lastRefresh > 10 * 1000) {\r\n      setRefresh((prev) => prev + 1);\r\n    } else {\r\n      console.log('not refreshing');\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (connected && wallet) {\r\n      const getAllOpenOrders = async () => {\r\n        setLoaded(false);\r\n        const _openOrders: { orders: Order[]; marketAddress: string }[] = [];\r\n        const getOpenOrdersForMarket = async (marketInfo: MarketInfo) => {\r\n          await sleep(1000 * Math.random()); // Try not to hit rate limit\r\n          try {\r\n            const market = await Market.load(\r\n              connection,\r\n              marketInfo.address,\r\n              undefined,\r\n              marketInfo.programId,\r\n            );\r\n            const orders = await market.loadOrdersForOwner(\r\n              connection,\r\n              wallet?.publicKey,\r\n              30000,\r\n            );\r\n            _openOrders.push({\r\n              orders: orders,\r\n              marketAddress: marketInfo.address.toBase58(),\r\n            });\r\n          } catch (e) {\r\n            console.warn(`Error loading open order ${marketInfo.name} - ${e}`);\r\n          }\r\n        };\r\n        await Promise.all(USE_MARKETS.map((m) => getOpenOrdersForMarket(m)));\r\n        setOpenOrders(_openOrders);\r\n        setLastRefresh(new Date().getTime());\r\n        setLoaded(true);\r\n      };\r\n      getAllOpenOrders();\r\n    }\r\n  }, [connection, connected, wallet, refresh]);\r\n  return {\r\n    openOrders: openOrders,\r\n    loaded: loaded,\r\n    refreshOpenOrders: refreshOpenOrders,\r\n  };\r\n};\r\n\r\nexport function useBalances(): Balances[] {\r\n  const baseCurrencyBalances = useSelectedBaseCurrencyBalances();\r\n  const quoteCurrencyBalances = useSelectedQuoteCurrencyBalances();\r\n  const openOrders = useSelectedOpenOrdersAccount(true);\r\n  const { baseCurrency, quoteCurrency, market } = useMarket();\r\n  const baseExists =\r\n    openOrders && openOrders.baseTokenTotal && openOrders.baseTokenFree;\r\n  const quoteExists =\r\n    openOrders && openOrders.quoteTokenTotal && openOrders.quoteTokenFree;\r\n  if (\r\n    baseCurrency === 'UNKNOWN' ||\r\n    quoteCurrency === 'UNKNOWN' ||\r\n    !baseCurrency ||\r\n    !quoteCurrency\r\n  ) {\r\n    return [];\r\n  }\r\n  return [\r\n    {\r\n      market,\r\n      key: `${baseCurrency}${quoteCurrency}${baseCurrency}`,\r\n      coin: baseCurrency,\r\n      wallet: baseCurrencyBalances,\r\n      orders:\r\n        baseExists && market && openOrders\r\n          ? market.baseSplSizeToNumber(\r\n              openOrders.baseTokenTotal.sub(openOrders.baseTokenFree),\r\n            )\r\n          : null,\r\n      openOrders,\r\n      unsettled:\r\n        baseExists && market && openOrders\r\n          ? market.baseSplSizeToNumber(openOrders.baseTokenFree)\r\n          : null,\r\n    },\r\n    {\r\n      market,\r\n      key: `${quoteCurrency}${baseCurrency}${quoteCurrency}`,\r\n      coin: quoteCurrency,\r\n      wallet: quoteCurrencyBalances,\r\n      openOrders,\r\n      orders:\r\n        quoteExists && market && openOrders\r\n          ? market.quoteSplSizeToNumber(\r\n              openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree),\r\n            )\r\n          : null,\r\n      unsettled:\r\n        quoteExists && market && openOrders\r\n          ? market.quoteSplSizeToNumber(openOrders.quoteTokenFree)\r\n          : null,\r\n    },\r\n  ];\r\n}\r\n\r\nexport function useWalletBalancesForAllMarkets(): {\r\n  mint: string;\r\n  balance: number;\r\n}[] {\r\n  const [tokenAccounts] = useTokenAccounts();\r\n  const { connected } = useWallet();\r\n  const [mintInfos, mintInfosConnected] = useMintInfos();\r\n\r\n  if (!connected || !mintInfosConnected) {\r\n    return [];\r\n  }\r\n\r\n  let balances: { [mint: string]: number } = {};\r\n  for (let account of tokenAccounts || []) {\r\n    if (!account.account) {\r\n      continue;\r\n    }\r\n    let parsedAccount;\r\n    if (account.effectiveMint.equals(WRAPPED_SOL_MINT)) {\r\n      parsedAccount = {\r\n        mint: WRAPPED_SOL_MINT,\r\n        owner: account.pubkey,\r\n        amount: account.account.lamports,\r\n      };\r\n    } else {\r\n      parsedAccount = parseTokenAccountData(account.account.data);\r\n    }\r\n    if (!(parsedAccount.mint.toBase58() in balances)) {\r\n      balances[parsedAccount.mint.toBase58()] = 0;\r\n    }\r\n    const mintInfo = mintInfos && mintInfos[parsedAccount.mint.toBase58()];\r\n    const additionalAmount = divideBnToNumber(\r\n      new BN(parsedAccount.amount),\r\n      getTokenMultiplierFromDecimals(mintInfo?.decimals || 0),\r\n    );\r\n    balances[parsedAccount.mint.toBase58()] += additionalAmount;\r\n  }\r\n  return Object.entries(balances).map(([mint, balance]) => {\r\n    return { mint, balance };\r\n  });\r\n}\r\n\r\nexport function useUnmigratedDeprecatedMarkets() {\r\n  const connection = useConnection();\r\n  const { accounts } = useUnmigratedOpenOrdersAccounts();\r\n  const marketsList =\r\n    accounts &&\r\n    Array.from(new Set(accounts.map((openOrders) => openOrders.market)));\r\n  const deps = marketsList && marketsList.map((m) => m.toBase58());\r\n\r\n  const useUnmigratedDeprecatedMarketsInner = async () => {\r\n    if (!marketsList) {\r\n      return null;\r\n    }\r\n    const getMarket = async (address) => {\r\n      const marketInfo = USE_MARKETS.find((market) =>\r\n        market.address.equals(address),\r\n      );\r\n      if (!marketInfo) {\r\n        console.log('Failed loading market');\r\n        notify({\r\n          message: 'Error loading market',\r\n          type: 'error',\r\n        });\r\n        return null;\r\n      }\r\n      try {\r\n        console.log('Loading market', marketInfo.name);\r\n        // NOTE: Should this just be cached by (connection, marketInfo.address, marketInfo.programId)?\r\n        return await Market.load(\r\n          connection,\r\n          marketInfo.address,\r\n          {},\r\n          marketInfo.programId,\r\n        );\r\n      } catch (e) {\r\n        console.log('Failed loading market', marketInfo.name, e);\r\n        notify({\r\n          message: 'Error loading market',\r\n          description: e.message,\r\n          type: 'error',\r\n        });\r\n        return null;\r\n      }\r\n    };\r\n    return (await Promise.all(marketsList.map(getMarket))).filter((x) => x);\r\n  };\r\n  const [markets] = useAsyncData(\r\n    useUnmigratedDeprecatedMarketsInner,\r\n    tuple(\r\n      'useUnmigratedDeprecatedMarketsInner',\r\n      connection,\r\n      deps && deps.toString(),\r\n    ),\r\n    { refreshInterval: _VERY_SLOW_REFRESH_INTERVAL },\r\n  );\r\n  if (!markets) {\r\n    return null;\r\n  }\r\n  return markets.map((market) => ({\r\n    market,\r\n    openOrdersList: accounts?.filter(\r\n      (openOrders) => market && openOrders.market.equals(market.address),\r\n    ),\r\n  }));\r\n}\r\n\r\nexport function useGetOpenOrdersForDeprecatedMarkets(): {\r\n  openOrders: OrderWithMarketAndMarketName[] | null | undefined;\r\n  loaded: boolean;\r\n  refreshOpenOrders: () => void;\r\n} {\r\n  const { connected, wallet } = useWallet();\r\n  const { customMarkets } = useCustomMarkets();\r\n  const connection = useConnection();\r\n  const marketsAndOrders = useUnmigratedDeprecatedMarkets();\r\n  const marketsList =\r\n    marketsAndOrders && marketsAndOrders.map(({ market }) => market);\r\n\r\n  // This isn't quite right: open order balances could change\r\n  const deps =\r\n    marketsList &&\r\n    marketsList\r\n      .filter((market): market is Market => !!market)\r\n      .map((market) => market.address.toBase58());\r\n\r\n  async function getOpenOrdersForDeprecatedMarkets() {\r\n    if (!connected || !wallet) {\r\n      return null;\r\n    }\r\n    if (!marketsList) {\r\n      return null;\r\n    }\r\n    console.log('refreshing getOpenOrdersForDeprecatedMarkets');\r\n    const getOrders = async (market: Market | null) => {\r\n      if (!market) {\r\n        return null;\r\n      }\r\n      const { marketName } = getMarketDetails(market, customMarkets);\r\n      try {\r\n        console.log('Fetching open orders for', marketName);\r\n        // Can do better than this, we have the open orders accounts already\r\n        return (\r\n          await market.loadOrdersForOwner(connection, wallet.publicKey)\r\n        ).map((order) => ({ marketName, market, ...order }));\r\n      } catch (e) {\r\n        console.log('Failed loading open orders', market.address.toBase58(), e);\r\n        notify({\r\n          message: `Error loading open orders for deprecated ${marketName}`,\r\n          description: e.message,\r\n          type: 'error',\r\n        });\r\n        return null;\r\n      }\r\n    };\r\n    return (await Promise.all(marketsList.map(getOrders)))\r\n      .filter((x): x is OrderWithMarketAndMarketName[] => !!x)\r\n      .flat();\r\n  }\r\n\r\n  const cacheKey = tuple(\r\n    'getOpenOrdersForDeprecatedMarkets',\r\n    connected,\r\n    connection,\r\n    wallet,\r\n    deps && deps.toString(),\r\n  );\r\n  const [openOrders, loaded] = useAsyncData(\r\n    getOpenOrdersForDeprecatedMarkets,\r\n    cacheKey,\r\n    {\r\n      refreshInterval: _VERY_SLOW_REFRESH_INTERVAL,\r\n    },\r\n  );\r\n  console.log('openOrders', openOrders);\r\n  return {\r\n    openOrders,\r\n    loaded,\r\n    refreshOpenOrders: () => refreshCache(cacheKey),\r\n  };\r\n}\r\n\r\nexport function useBalancesForDeprecatedMarkets() {\r\n  const markets = useUnmigratedDeprecatedMarkets();\r\n  const [customMarkets] = useLocalStorageState<CustomMarketInfo[]>(\r\n    'customMarkets',\r\n    [],\r\n  );\r\n  if (!markets) {\r\n    return null;\r\n  }\r\n\r\n  const openOrderAccountBalances: DeprecatedOpenOrdersBalances[] = [];\r\n  markets.forEach(({ market, openOrdersList }) => {\r\n    const { baseCurrency, quoteCurrency, marketName } = getMarketDetails(\r\n      market,\r\n      customMarkets,\r\n    );\r\n    if (!baseCurrency || !quoteCurrency || !market) {\r\n      return;\r\n    }\r\n    (openOrdersList || []).forEach((openOrders) => {\r\n      const inOrdersBase =\r\n        openOrders?.baseTokenTotal &&\r\n        openOrders?.baseTokenFree &&\r\n        market.baseSplSizeToNumber(\r\n          openOrders.baseTokenTotal.sub(openOrders.baseTokenFree),\r\n        );\r\n      const inOrdersQuote =\r\n        openOrders?.quoteTokenTotal &&\r\n        openOrders?.quoteTokenFree &&\r\n        market.baseSplSizeToNumber(\r\n          openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree),\r\n        );\r\n      const unsettledBase =\r\n        openOrders?.baseTokenFree &&\r\n        market.baseSplSizeToNumber(openOrders.baseTokenFree);\r\n      const unsettledQuote =\r\n        openOrders?.quoteTokenFree &&\r\n        market.baseSplSizeToNumber(openOrders.quoteTokenFree);\r\n\r\n      openOrderAccountBalances.push({\r\n        marketName,\r\n        market,\r\n        coin: baseCurrency,\r\n        key: `${marketName}${baseCurrency}`,\r\n        orders: inOrdersBase,\r\n        unsettled: unsettledBase,\r\n        openOrders,\r\n      });\r\n      openOrderAccountBalances.push({\r\n        marketName,\r\n        market,\r\n        coin: quoteCurrency,\r\n        key: `${marketName}${quoteCurrency}`,\r\n        orders: inOrdersQuote,\r\n        unsettled: unsettledQuote,\r\n        openOrders,\r\n      });\r\n    });\r\n  });\r\n  return openOrderAccountBalances;\r\n}\r\n\r\nexport function getMarketInfos(\r\n  customMarkets: CustomMarketInfo[],\r\n): MarketInfo[] {\r\n  const customMarketsInfo = customMarkets\r\n    .filter(\r\n      (item) =>\r\n        !USE_MARKETS.find(\r\n          (itemNew) =>\r\n            itemNew.address.toString() === item.address &&\r\n            itemNew.deprecated === true,\r\n        ),\r\n    )\r\n    .map((m) => ({\r\n      ...m,\r\n      address: new PublicKey(m.address),\r\n      programId: new PublicKey(m.programId),\r\n      deprecated: false,\r\n    }));\r\n\r\n  return [...customMarketsInfo, ...USE_MARKETS];\r\n}\r\n\r\nexport function useMarketInfos() {\r\n  const { customMarkets } = useCustomMarkets();\r\n  return getMarketInfos(customMarkets);\r\n}\r\n\r\n/**\r\n * If selling, choose min tick size. If buying choose a price\r\n * s.t. given the state of the orderbook, the order will spend\r\n * `cost` cost currency.\r\n *\r\n * @param orderbook serum Orderbook object\r\n * @param cost quantity to spend. Base currency if selling,\r\n *  quote currency if buying.\r\n * @param tickSizeDecimals size of price increment of the market\r\n */\r\nexport function getMarketOrderPrice(\r\n  orderbook: Orderbook,\r\n  cost: number,\r\n  tickSizeDecimals?: number,\r\n) {\r\n  if (orderbook.isBids) {\r\n    return orderbook.market.tickSize;\r\n  }\r\n  let spentCost = 0;\r\n  let price, sizeAtLevel, costAtLevel: number;\r\n  const asks = orderbook.getL2(1000);\r\n  for ([price, sizeAtLevel] of asks) {\r\n    costAtLevel = price * sizeAtLevel;\r\n    if (spentCost + costAtLevel > cost) {\r\n      break;\r\n    }\r\n    spentCost += costAtLevel;\r\n  }\r\n  const sendPrice = Math.min(price * 1.02, asks[0][0] * 1.05);\r\n  let formattedPrice;\r\n  if (tickSizeDecimals) {\r\n    formattedPrice = floorToDecimal(sendPrice, tickSizeDecimals);\r\n  } else {\r\n    formattedPrice = sendPrice;\r\n  }\r\n  return formattedPrice;\r\n}\r\n\r\nexport function getExpectedFillPrice(\r\n  orderbook: Orderbook,\r\n  cost: number,\r\n  tickSizeDecimals?: number,\r\n) {\r\n  let spentCost = 0;\r\n  let avgPrice = 0;\r\n  let price, sizeAtLevel, costAtLevel: number;\r\n  for ([price, sizeAtLevel] of orderbook.getL2(1000)) {\r\n    costAtLevel = (orderbook.isBids ? 1 : price) * sizeAtLevel;\r\n    if (spentCost + costAtLevel > cost) {\r\n      avgPrice += (cost - spentCost) * price;\r\n      spentCost = cost;\r\n      break;\r\n    }\r\n    avgPrice += costAtLevel * price;\r\n    spentCost += costAtLevel;\r\n  }\r\n  const totalAvgPrice = avgPrice / Math.min(cost, spentCost);\r\n  let formattedPrice;\r\n  if (tickSizeDecimals) {\r\n    formattedPrice = floorToDecimal(totalAvgPrice, tickSizeDecimals);\r\n  } else {\r\n    formattedPrice = totalAvgPrice;\r\n  }\r\n  return formattedPrice;\r\n}\r\n\r\nexport function useCurrentlyAutoSettling(): [\r\n  boolean,\r\n  (currentlyAutoSettling: boolean) => void,\r\n] {\r\n  const [currentlyAutoSettling, setCurrentlyAutosettling] =\r\n    useState<boolean>(false);\r\n  return [currentlyAutoSettling, setCurrentlyAutosettling];\r\n}\r\n"]},"metadata":{},"sourceType":"module"}